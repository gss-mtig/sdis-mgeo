{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Infraestructuras de datos espaciales y est\u00e1ndares de geoservicios 2020-2021 Materiales para el curso sobre Infraestructuras de datos espaciales y est\u00e1ndares de geoservicios (SDIS) del M\u00e0ster en Geoinformaci\u00f3 de la UAB Temario: https://gss-mtig.github.io/sdis-mgeo-20-21/ Introducci\u00f3n a las IDE's Antecedentes Qu\u00e9 es una IDE? Componentes de una IDE IDEC IDEE INSPIRE Otras IDES Est\u00e1ndares OCG Est\u00e1ndares ISO Visualizaci\u00f3n con Kepler.gl Herramientas de visualizaci\u00f3n de datos Conceptos b\u00e1sicos de Geoservicios Ejemplo servicio WMS Consideraciones sobre servicios Open data Ejemplo servicio bicing Barcelona Ejemplo servicio bicing Barcelona (VectorTiles) Consideraciones sobre servicios de Sensores Ejemplo Sentilo ACA Geoservicios realtime Herramientas de visualizaci\u00f3n geoservicios Ejemplo Mobility Ejemplo servicio realtime para compartir la ubicaci\u00f3n Ejemplo GTFS Autores Wladimir Szczerban (alias Bolo) @bolosig , geostarter (ICGC) Victor Pascual Ayats @sfggeogis , geostarter (ICGC) Ignacio Ferrero (Departamento de Geograf\u00eda UAB) Condiciones de reutilizaci\u00f3n de estos apuntes Estos materiales est\u00e1n publicados bajo licencia CreativeCommons (by-sa) 4.0 internacional Usted es libre de: * Compartir \u2014 copiar y redistribuir el material en cualquier medio o formato * Adaptar \u2014 remezclar, transformar y crear a partir del material para cualquier finalidad, incluso comercial. Bajo las condiciones siguientes: Reconocimiento \u2014 Debe reconocer adecuadamente la autor\u00eda, proporcionar un enlace a la licencia e indicar si se han realizado cambios. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. CompartirIgual \u2014 Si remezcla, transforma o crea a partir del material, deber\u00e1 difundir sus contribuciones bajo la misma licencia que el original. No hay restricciones adicionales \u2014 No puede aplicar t\u00e9rminos legales o medidas tecnol\u00f3gicas que legalmente restrinjan realizar aquello que la licencia permite.","title":"Home"},{"location":"#infraestructuras-de-datos-espaciales-y-estandares-de-geoservicios-2020-2021","text":"Materiales para el curso sobre Infraestructuras de datos espaciales y est\u00e1ndares de geoservicios (SDIS) del M\u00e0ster en Geoinformaci\u00f3 de la UAB Temario:","title":"Infraestructuras de datos espaciales y est\u00e1ndares de geoservicios 2020-2021"},{"location":"#httpsgss-mtiggithubiosdis-mgeo-20-21","text":"Introducci\u00f3n a las IDE's Antecedentes Qu\u00e9 es una IDE? Componentes de una IDE IDEC IDEE INSPIRE Otras IDES Est\u00e1ndares OCG Est\u00e1ndares ISO Visualizaci\u00f3n con Kepler.gl Herramientas de visualizaci\u00f3n de datos Conceptos b\u00e1sicos de Geoservicios Ejemplo servicio WMS Consideraciones sobre servicios Open data Ejemplo servicio bicing Barcelona Ejemplo servicio bicing Barcelona (VectorTiles) Consideraciones sobre servicios de Sensores Ejemplo Sentilo ACA Geoservicios realtime Herramientas de visualizaci\u00f3n geoservicios Ejemplo Mobility Ejemplo servicio realtime para compartir la ubicaci\u00f3n Ejemplo GTFS","title":"https://gss-mtig.github.io/sdis-mgeo-20-21/"},{"location":"#autores","text":"Wladimir Szczerban (alias Bolo) @bolosig , geostarter (ICGC) Victor Pascual Ayats @sfggeogis , geostarter (ICGC) Ignacio Ferrero (Departamento de Geograf\u00eda UAB) Condiciones de reutilizaci\u00f3n de estos apuntes Estos materiales est\u00e1n publicados bajo licencia CreativeCommons (by-sa) 4.0 internacional Usted es libre de: * Compartir \u2014 copiar y redistribuir el material en cualquier medio o formato * Adaptar \u2014 remezclar, transformar y crear a partir del material para cualquier finalidad, incluso comercial. Bajo las condiciones siguientes: Reconocimiento \u2014 Debe reconocer adecuadamente la autor\u00eda, proporcionar un enlace a la licencia e indicar si se han realizado cambios. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. CompartirIgual \u2014 Si remezcla, transforma o crea a partir del material, deber\u00e1 difundir sus contribuciones bajo la misma licencia que el original. No hay restricciones adicionales \u2014 No puede aplicar t\u00e9rminos legales o medidas tecnol\u00f3gicas que legalmente restrinjan realizar aquello que la licencia permite.","title":"Autores"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/","text":"Ejemplo servicio bicing Barcelona VectorTiles Acceso al servicio de datos del Bicing de Barcelona En el portal Open data del Ayuntamiento de Barcelona podemos encontrar un dataset (conjunto de datos) que contiene las estaciones del servicio de Bicing Anteriormente ten\u00edan un servicio donde daban toda la informaci\u00f3n de la estaci\u00f3n en tiempo real http://wservice.viabicing.cat/v2/stations . Actualmente lo han separado en dos servicios unos con la informaci\u00f3n de las estaciones (identificador, nombre, coordenadas, etc.) y otro con estado de las estaciones (n\u00famero de bicis disponibles, tipos de bicis, etc) Si bien el Ayuntamiento de Barcelona no ofrece explicitamente el acceso a los datos del Bicing como un servicio, si que tiene un servicio de datos en tiempo real. La url la podemos encontrar presionando el bot\u00f3n de Descargar del recurso json url servicio de bicing Al abrir la url https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information en nuestro navegador observaremos que la respuesta es un archivo json con un conjunto de elementos que tienen las coordenadas de la localizaci\u00f3n de la estaci\u00f3n de bicing, la direcci\u00f3n, la capacidad, etc. Mapa que utiliza este servicio, https://www.bicing.barcelona/es/mapa-de-disponibilidad-provisional El archivo json que retorna el servicio tiene coordenadas pero no es un fichero GeoJSON. 1 Para ver estos datos sobre un mapa crearemos un visor utilizando Mapbox GL JS. 2 Creaci\u00f3n de un visor Crer una carpeta con el nombre de visor-bicing-vt . Crer una carpeta con el nombre de public dentro de la carpeta visor-bicing-vt. Crear un archivo con el nombre de index.html dentro de la carpeta public. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para ver que carga un mapa centrado en Barcelona. Creaci\u00f3n del proxy Crearemos un proxy que nos permita Instalar Node.js 3 . Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 12.13.1 LTS) y lo instalaremos con las opciones por defecto. Una vez instalado el Node abrir la consola para verificar que se ha instalado correctamente. Escribir node -v Navegar hasta nuestra carpeta visor-bicing-vt y escribir: npm init Con este comando estaremos creando el archivo package.json . Este comando solicita varios elementos como, por ejemplo, el nombre y la versi\u00f3n de la aplicaci\u00f3n. Por ahora, s\u00f3lo hay que pulsar ENTER para aceptar los valores predeterminados. Instalar las dependencias para crear nuestro servicio de proxy 4 . En este caso utilizaremos Express 5 como servidor web y el m\u00f3dulo axios 6 . Instalar el express y guardarlo en la lista de dependencias npm install express --save Instalar el axios y guardarlo en la lista de dependencias npm install axios --save Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que servir\u00e1 de proxy con el servicio de Bicing. Copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var axios = require ( 'axios' ); var serverBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ; app . use ( express . static ( 'public' )); app . all ( \"/bicingjson/*\" , function ( req , res ) { console . log ( 'redirecting to Server2' ); var geojson = { type : 'FeatureCollection' , features : [] }; axios . get ( serverBicing ). then ( function ( response ){ // handle success var stations = response . data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } res . send ( geojson ); }). catch ( function ( error ) { console . log ( error ); res . send ( error ); }); }); app . listen ( 3000 ); Probar que nuestro proxy est\u00e1 funcionando, escribiendo: node app.js Abrir la url de nuestro proxy http://localhost:3000/bicingjson/ en el navegador. Escribir en el navegador http://localhost:3000 para ver nuestro mapa. Modificar el visor Modificar el archivo index.html para que llame al proxy que hemos creado y cargue la capa de bicing. Escribir justo despues de la declaraci\u00f3n del mapa. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : 6 , \"circle-color\" : \"#B42222\" }, }); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos los puntos de las estaciones de bicing. Actualizar los datos del mapa. Para actualizar los datos del mapa se debe recargar la capa de estaciones de bicing cada X tiempo. Para recargar la capa cada 3 segundos escribir los siguiente al final de la funci\u00f3n que se llama al terminar de cargar el estilo del mapa. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : 6 , \"circle-color\" : \"#B42222\" }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos los puntos de las estaciones de bicing. Si vamos a la pesta\u00f1a de red (network) en la consola de desarrollador del navegador podremos ver que cada 3 segundos se hace una llamada a nuestro proxy. Cambiar el estilo de la capa de estaciones de bicing. Para representar las estaciones con un estilo basado en los valores de algunos de sus atributos utilizar el data-driven style siguiendo la especificaci\u00f3n de estilo de Mapbox 7 . Modificar la propiedad paint de la capa y escribir <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"altitude\" ]], 0 , \"hsl(0, 88%, 55%)\" , 50 , \"hsl(108, 93%, 59%)\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos el cambio de estilo de los puntos de las estaciones de bicing. Crear un popup para ver la informaci\u00f3n de la estaci\u00f3n al seleccionarla. Escribir despu\u00e9s de donde definimos el onload <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"altitude\" ]], 0 , \"hsl(0, 88%, 55%)\" , 50 , \"hsl(108, 93%, 59%)\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); map . on ( 'click' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); // if the features have no info, return nothing if ( ! features . length ) { return ; } var feature = features [ 0 ]; // Populate the popup and set its coordinates // based on the feature found var popup = new mapboxgl . Popup () . setLngLat ( feature . geometry . coordinates ) . setHTML ( '<div id=\\'popup\\' class=\\'popup\\' style=\\'z-index: 10;\\'> <h5> ' + feature . properties . id + ' </h5>' + '<ul class=\\'list-group\\'>' + '<li class=\\'list-group-item\\'> ' + feature . properties . address + ' </li>' + '<li class=\\'list-group-item\\'> Altitud: ' + feature . properties . altitude + ' </li>' + '<li class=\\'list-group-item\\'> Capacidad: ' + feature . properties . capacity + ' </li></ul></div>' ) . addTo ( map ); }); </ script > </ body > </ html > Recargar la p\u00e1gina y hacer click sobre alguna estaci\u00f3n para ver su informaci\u00f3n en tiempo real. Cambiar el tipo de cursor al pasar sobre una estaci\u00f3n. Escribir despu\u00e9s de donde definimos el onload <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"altitude\" ]], 0 , \"hsl(0, 88%, 55%)\" , 50 , \"hsl(108, 93%, 59%)\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); map . on ( 'click' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); // if the features have no info, return nothing if ( ! features . length ) { return ; } var feature = features [ 0 ]; // Populate the popup and set its coordinates // based on the feature found var popup = new mapboxgl . Popup () . setLngLat ( feature . geometry . coordinates ) . setHTML ( '<div id=\\'popup\\' class=\\'popup\\' style=\\'z-index: 10;\\'> <h5> ' + feature . properties . id + ' </h5>' + '<ul class=\\'list-group\\'>' + '<li class=\\'list-group-item\\'> ' + feature . properties . streetName + ' </li>' + '<li class=\\'list-group-item\\'> Bikes: ' + feature . properties . bikes + ' </li>' + '<li class=\\'list-group-item\\'> slots: ' + feature . properties . slots + ' </li></ul></div>' ) . addTo ( map ); }); // Use the same approach as above to indicate that the symbols are clickable // by changing the cursor style to 'pointer' map . on ( 'mousemove' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); map . getCanvas (). style . cursor = features . length ? 'pointer' : '' ; }); </ script > </ body > </ html > Recargar la p\u00e1gina y pasar sobre alguna estaci\u00f3n para ver el cambio del cursor. mapa de servicio de bicing Modificar el proxy Modificaremos el proxy para agregar los datos de disponibilidad de bicis en las estaciones. Para ello debemos llamar al servicio de estado de estaciones . Al abrir la url del servicio podemos ver que est\u00e1 el listado de las estaciones con una serie de datos. En este caso no hay datos de posici\u00f3n, ni de descripci\u00f3n s\u00f3lo datos del estado de la estaci\u00f3n. Podemos ver que tambi\u00e9n hay un campo con el station_id que nos servir\u00e1 para vincular los datos de estado de la estaci\u00f3n con la estaci\u00f3n correspondiente. Agregar la url del servicio de estado de estaciones var express = require ( 'express' ); var app = express (); var axios = require ( 'axios' ); var serverBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ; var statusBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_status' ; app . use ( express . static ( 'public' )); app . all ( \"/bicingjson/*\" , function ( req , res ) { console . log ( 'redirecting to Server2' ); var geojson = { type : 'FeatureCollection' , features : [] }; axios . get ( serverBicing ). then ( function ( response ){ // handle success var stations = response . data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } res . send ( geojson ); }). catch ( function ( error ) { console . log ( error ); res . send ( error ); }); }); app . listen ( 3000 ); Combinar la informaci\u00f3n del estado de estaciones con la informaci\u00f3n de la estaci\u00f3n var express = require ( 'express' ); var app = express (); var axios = require ( 'axios' ); var serverBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ; var statusBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_status' ; app . use ( express . static ( 'public' )); app . all ( \"/bicingjson/*\" , function ( req , res ) { console . log ( 'redirecting to Server2' ); var geojson = { type : 'FeatureCollection' , features : [] }; Promise . all ([ axios . get ( serverBicing ), axios . get ( statusBicing )]). then (( responses ) => { var stations = responses [ 0 ]. data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } var status = responses [ 1 ]. data . data . stations ; for ( var i = status . length - 1 ; i >= 0 ; i -- ) { var stat = status [ i ]; for ( var j = geojson . features . length - 1 ; j >= 0 ; j -- ) { var feat = geojson . features [ j ]; if ( feat . properties . id === stat . station_id ) { feat . properties . num_bikes_available = stat . num_bikes_available ; feat . properties . num_bikes_available_types = stat . num_bikes_available_types ; feat . properties . num_docks_available = stat . num_docks_available ; } } } res . send ( geojson ); }). catch ( function ( error ) { console . log ( error ); res . send ( error ); }); }); app . listen ( 3000 ); Modificar el visor Modificaremos el visor para cambiar el color del c\u00edrculo dependiendo del n\u00famere de bicis disponibles en la estaci\u00f3n <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"num_bikes_available\" ]], 0 , \"#ff0000\" , 15 , \"#00ff00\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); map . on ( 'click' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); // if the features have no info, return nothing if ( ! features . length ) { return ; } var feature = features [ 0 ]; // Populate the popup and set its coordinates // based on the feature found var popup = new mapboxgl . Popup () . setLngLat ( feature . geometry . coordinates ) . setHTML ( '<div id=\\'popup\\' class=\\'popup\\' style=\\'z-index: 10;\\'> <h5> ' + feature . properties . id + ' </h5>' + '<ul class=\\'list-group\\'>' + '<li class=\\'list-group-item\\'> ' + feature . properties . streetName + ' </li>' + '<li class=\\'list-group-item\\'> Bikes: ' + feature . properties . bikes + ' </li>' + '<li class=\\'list-group-item\\'> slots: ' + feature . properties . slots + ' </li></ul></div>' ) . addTo ( map ); }); // Use the same approach as above to indicate that the symbols are clickable // by changing the cursor style to 'pointer' map . on ( 'mousemove' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); map . getCanvas (). style . cursor = features . length ? 'pointer' : '' ; }); </ script > </ body > </ html > Ejercicio Cambiar el estilo de los puntos de las estaciones. Cambiar los rangos del tama\u00f1o del punto y cambiar el rango de colores. Referencias https://es.wikipedia.org/wiki/GeoJSON \u21a9 https://www.mapbox.com/mapbox-gl-js/api/ \u21a9 https://nodejs.org/es/ \u21a9 https://es.wikipedia.org/wiki/Servidor_proxy \u21a9 http://expressjs.com/ \u21a9 https://github.com/axios/axios \u21a9 https://www.mapbox.com/mapbox-gl-js/style-spec \u21a9","title":"10. Ejemplo servicio bicing Barcelona (VectorTiles)"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#ejemplo-servicio-bicing-barcelona-vectortiles","text":"","title":"Ejemplo servicio bicing Barcelona VectorTiles"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#acceso-al-servicio-de-datos-del-bicing-de-barcelona","text":"En el portal Open data del Ayuntamiento de Barcelona podemos encontrar un dataset (conjunto de datos) que contiene las estaciones del servicio de Bicing Anteriormente ten\u00edan un servicio donde daban toda la informaci\u00f3n de la estaci\u00f3n en tiempo real http://wservice.viabicing.cat/v2/stations . Actualmente lo han separado en dos servicios unos con la informaci\u00f3n de las estaciones (identificador, nombre, coordenadas, etc.) y otro con estado de las estaciones (n\u00famero de bicis disponibles, tipos de bicis, etc) Si bien el Ayuntamiento de Barcelona no ofrece explicitamente el acceso a los datos del Bicing como un servicio, si que tiene un servicio de datos en tiempo real. La url la podemos encontrar presionando el bot\u00f3n de Descargar del recurso json url servicio de bicing Al abrir la url https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information en nuestro navegador observaremos que la respuesta es un archivo json con un conjunto de elementos que tienen las coordenadas de la localizaci\u00f3n de la estaci\u00f3n de bicing, la direcci\u00f3n, la capacidad, etc. Mapa que utiliza este servicio, https://www.bicing.barcelona/es/mapa-de-disponibilidad-provisional El archivo json que retorna el servicio tiene coordenadas pero no es un fichero GeoJSON. 1 Para ver estos datos sobre un mapa crearemos un visor utilizando Mapbox GL JS. 2","title":"Acceso al servicio de datos del Bicing de Barcelona"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#creacion-de-un-visor","text":"Crer una carpeta con el nombre de visor-bicing-vt . Crer una carpeta con el nombre de public dentro de la carpeta visor-bicing-vt. Crear un archivo con el nombre de index.html dentro de la carpeta public. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para ver que carga un mapa centrado en Barcelona.","title":"Creaci\u00f3n de un visor"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#creacion-del-proxy","text":"Crearemos un proxy que nos permita Instalar Node.js 3 . Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 12.13.1 LTS) y lo instalaremos con las opciones por defecto. Una vez instalado el Node abrir la consola para verificar que se ha instalado correctamente. Escribir node -v Navegar hasta nuestra carpeta visor-bicing-vt y escribir: npm init Con este comando estaremos creando el archivo package.json . Este comando solicita varios elementos como, por ejemplo, el nombre y la versi\u00f3n de la aplicaci\u00f3n. Por ahora, s\u00f3lo hay que pulsar ENTER para aceptar los valores predeterminados. Instalar las dependencias para crear nuestro servicio de proxy 4 . En este caso utilizaremos Express 5 como servidor web y el m\u00f3dulo axios 6 . Instalar el express y guardarlo en la lista de dependencias npm install express --save Instalar el axios y guardarlo en la lista de dependencias npm install axios --save Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que servir\u00e1 de proxy con el servicio de Bicing. Copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var axios = require ( 'axios' ); var serverBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ; app . use ( express . static ( 'public' )); app . all ( \"/bicingjson/*\" , function ( req , res ) { console . log ( 'redirecting to Server2' ); var geojson = { type : 'FeatureCollection' , features : [] }; axios . get ( serverBicing ). then ( function ( response ){ // handle success var stations = response . data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } res . send ( geojson ); }). catch ( function ( error ) { console . log ( error ); res . send ( error ); }); }); app . listen ( 3000 ); Probar que nuestro proxy est\u00e1 funcionando, escribiendo: node app.js Abrir la url de nuestro proxy http://localhost:3000/bicingjson/ en el navegador. Escribir en el navegador http://localhost:3000 para ver nuestro mapa.","title":"Creaci\u00f3n del proxy"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#modificar-el-visor","text":"Modificar el archivo index.html para que llame al proxy que hemos creado y cargue la capa de bicing. Escribir justo despues de la declaraci\u00f3n del mapa. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : 6 , \"circle-color\" : \"#B42222\" }, }); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos los puntos de las estaciones de bicing. Actualizar los datos del mapa. Para actualizar los datos del mapa se debe recargar la capa de estaciones de bicing cada X tiempo. Para recargar la capa cada 3 segundos escribir los siguiente al final de la funci\u00f3n que se llama al terminar de cargar el estilo del mapa. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : 6 , \"circle-color\" : \"#B42222\" }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos los puntos de las estaciones de bicing. Si vamos a la pesta\u00f1a de red (network) en la consola de desarrollador del navegador podremos ver que cada 3 segundos se hace una llamada a nuestro proxy. Cambiar el estilo de la capa de estaciones de bicing. Para representar las estaciones con un estilo basado en los valores de algunos de sus atributos utilizar el data-driven style siguiendo la especificaci\u00f3n de estilo de Mapbox 7 . Modificar la propiedad paint de la capa y escribir <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"altitude\" ]], 0 , \"hsl(0, 88%, 55%)\" , 50 , \"hsl(108, 93%, 59%)\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos el cambio de estilo de los puntos de las estaciones de bicing. Crear un popup para ver la informaci\u00f3n de la estaci\u00f3n al seleccionarla. Escribir despu\u00e9s de donde definimos el onload <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"altitude\" ]], 0 , \"hsl(0, 88%, 55%)\" , 50 , \"hsl(108, 93%, 59%)\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); map . on ( 'click' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); // if the features have no info, return nothing if ( ! features . length ) { return ; } var feature = features [ 0 ]; // Populate the popup and set its coordinates // based on the feature found var popup = new mapboxgl . Popup () . setLngLat ( feature . geometry . coordinates ) . setHTML ( '<div id=\\'popup\\' class=\\'popup\\' style=\\'z-index: 10;\\'> <h5> ' + feature . properties . id + ' </h5>' + '<ul class=\\'list-group\\'>' + '<li class=\\'list-group-item\\'> ' + feature . properties . address + ' </li>' + '<li class=\\'list-group-item\\'> Altitud: ' + feature . properties . altitude + ' </li>' + '<li class=\\'list-group-item\\'> Capacidad: ' + feature . properties . capacity + ' </li></ul></div>' ) . addTo ( map ); }); </ script > </ body > </ html > Recargar la p\u00e1gina y hacer click sobre alguna estaci\u00f3n para ver su informaci\u00f3n en tiempo real. Cambiar el tipo de cursor al pasar sobre una estaci\u00f3n. Escribir despu\u00e9s de donde definimos el onload <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"altitude\" ]], 0 , \"hsl(0, 88%, 55%)\" , 50 , \"hsl(108, 93%, 59%)\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); map . on ( 'click' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); // if the features have no info, return nothing if ( ! features . length ) { return ; } var feature = features [ 0 ]; // Populate the popup and set its coordinates // based on the feature found var popup = new mapboxgl . Popup () . setLngLat ( feature . geometry . coordinates ) . setHTML ( '<div id=\\'popup\\' class=\\'popup\\' style=\\'z-index: 10;\\'> <h5> ' + feature . properties . id + ' </h5>' + '<ul class=\\'list-group\\'>' + '<li class=\\'list-group-item\\'> ' + feature . properties . streetName + ' </li>' + '<li class=\\'list-group-item\\'> Bikes: ' + feature . properties . bikes + ' </li>' + '<li class=\\'list-group-item\\'> slots: ' + feature . properties . slots + ' </li></ul></div>' ) . addTo ( map ); }); // Use the same approach as above to indicate that the symbols are clickable // by changing the cursor style to 'pointer' map . on ( 'mousemove' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); map . getCanvas (). style . cursor = features . length ? 'pointer' : '' ; }); </ script > </ body > </ html > Recargar la p\u00e1gina y pasar sobre alguna estaci\u00f3n para ver el cambio del cursor. mapa de servicio de bicing","title":"Modificar el visor"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#modificar-el-proxy","text":"Modificaremos el proxy para agregar los datos de disponibilidad de bicis en las estaciones. Para ello debemos llamar al servicio de estado de estaciones . Al abrir la url del servicio podemos ver que est\u00e1 el listado de las estaciones con una serie de datos. En este caso no hay datos de posici\u00f3n, ni de descripci\u00f3n s\u00f3lo datos del estado de la estaci\u00f3n. Podemos ver que tambi\u00e9n hay un campo con el station_id que nos servir\u00e1 para vincular los datos de estado de la estaci\u00f3n con la estaci\u00f3n correspondiente. Agregar la url del servicio de estado de estaciones var express = require ( 'express' ); var app = express (); var axios = require ( 'axios' ); var serverBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ; var statusBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_status' ; app . use ( express . static ( 'public' )); app . all ( \"/bicingjson/*\" , function ( req , res ) { console . log ( 'redirecting to Server2' ); var geojson = { type : 'FeatureCollection' , features : [] }; axios . get ( serverBicing ). then ( function ( response ){ // handle success var stations = response . data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } res . send ( geojson ); }). catch ( function ( error ) { console . log ( error ); res . send ( error ); }); }); app . listen ( 3000 ); Combinar la informaci\u00f3n del estado de estaciones con la informaci\u00f3n de la estaci\u00f3n var express = require ( 'express' ); var app = express (); var axios = require ( 'axios' ); var serverBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ; var statusBicing = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_status' ; app . use ( express . static ( 'public' )); app . all ( \"/bicingjson/*\" , function ( req , res ) { console . log ( 'redirecting to Server2' ); var geojson = { type : 'FeatureCollection' , features : [] }; Promise . all ([ axios . get ( serverBicing ), axios . get ( statusBicing )]). then (( responses ) => { var stations = responses [ 0 ]. data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } var status = responses [ 1 ]. data . data . stations ; for ( var i = status . length - 1 ; i >= 0 ; i -- ) { var stat = status [ i ]; for ( var j = geojson . features . length - 1 ; j >= 0 ; j -- ) { var feat = geojson . features [ j ]; if ( feat . properties . id === stat . station_id ) { feat . properties . num_bikes_available = stat . num_bikes_available ; feat . properties . num_bikes_available_types = stat . num_bikes_available_types ; feat . properties . num_docks_available = stat . num_docks_available ; } } } res . send ( geojson ); }). catch ( function ( error ) { console . log ( error ); res . send ( error ); }); }); app . listen ( 3000 );","title":"Modificar el proxy"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#modificar-el-visor_1","text":"Modificaremos el visor para cambiar el color del c\u00edrculo dependiendo del n\u00famere de bicis disponibles en la estaci\u00f3n <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime VectorTiles </ title > < meta name = 'viewport' content = 'initial-scale=1,maximum-scale=1,user-scalable=no' /> < script src = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js' ></ script > < link href = 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel = 'stylesheet' /> < style > body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; height : 100 % } </ style > </ head > < body > < div id = \"map\" ></ div > < script type = \"text/javascript\" > var map = new mapboxgl . Map ({ container : 'map' , style : 'https://geoserveis.icgc.cat/contextmaps/icgc.json' , center : [ 2.1777 , 41.3887 ], zoom : 13 , maxZoom : 14 , hash : true , }); map . on ( \"load\" , function () { //funcion que se llama al terminar de cargar el estilo del mapa //agregamos la fuente de datos al mapa map . addSource ( 'bicing-source' , { type : 'geojson' , data : 'http://localhost:3000/bicingjson/' }); //agregamos la capa con su estilo al mapa map . addLayer ({ \"id\" : \"bicing\" , \"type\" : \"circle\" , \"source\" : \"bicing-source\" , \"paint\" : { \"circle-radius\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ 'get' , 'capacity' ]], 15 , 5 , 50 , 33 ], \"circle-color\" : [ \"interpolate\" , [ \"linear\" ], [ \"to-number\" , [ \"get\" , \"num_bikes_available\" ]], 0 , \"#ff0000\" , 15 , \"#00ff00\" ], \"circle-opacity\" : 0.86 }, }); window . setInterval ( function () { map . getSource ( 'bicing-source' ). setData ( 'http://localhost:3000/bicingjson/' ); }, 3000 ); }); map . on ( 'click' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); // if the features have no info, return nothing if ( ! features . length ) { return ; } var feature = features [ 0 ]; // Populate the popup and set its coordinates // based on the feature found var popup = new mapboxgl . Popup () . setLngLat ( feature . geometry . coordinates ) . setHTML ( '<div id=\\'popup\\' class=\\'popup\\' style=\\'z-index: 10;\\'> <h5> ' + feature . properties . id + ' </h5>' + '<ul class=\\'list-group\\'>' + '<li class=\\'list-group-item\\'> ' + feature . properties . streetName + ' </li>' + '<li class=\\'list-group-item\\'> Bikes: ' + feature . properties . bikes + ' </li>' + '<li class=\\'list-group-item\\'> slots: ' + feature . properties . slots + ' </li></ul></div>' ) . addTo ( map ); }); // Use the same approach as above to indicate that the symbols are clickable // by changing the cursor style to 'pointer' map . on ( 'mousemove' , function ( e ) { var features = map . queryRenderedFeatures ( e . point , { layers : [ 'bicing' ] }); map . getCanvas (). style . cursor = features . length ? 'pointer' : '' ; }); </ script > </ body > </ html > Ejercicio Cambiar el estilo de los puntos de las estaciones. Cambiar los rangos del tama\u00f1o del punto y cambiar el rango de colores.","title":"Modificar el visor"},{"location":"10_ejemplo_servicio_bicing_bcn_vt/#referencias","text":"https://es.wikipedia.org/wiki/GeoJSON \u21a9 https://www.mapbox.com/mapbox-gl-js/api/ \u21a9 https://nodejs.org/es/ \u21a9 https://es.wikipedia.org/wiki/Servidor_proxy \u21a9 http://expressjs.com/ \u21a9 https://github.com/axios/axios \u21a9 https://www.mapbox.com/mapbox-gl-js/style-spec \u21a9","title":"Referencias"},{"location":"11_consideraciones_servicios_realtime_sensores/","text":"Consideraciones sobre servicios de Sensores Problemas frecuentes al trabajar con sensores Existe el estandar SOS de la OGC 1 , pero tiene poca implementaci\u00f3n, debido a que algunos de los fabricantes de sensores utilizan formatos propios, lo que dificulta la integraci\u00f3n de sensores de diferentes provedores en un s\u00f3lo sistema. Datos err\u00f3neos y falsos, ya sea por una mala lectura \u00f3 porque el sensor no est\u00e1 funcionando correctamente. No tenemos forma de saber si el dato es correcto. Ejemplo Ejemplo de buenas pr\u00e1cticas El servicio de datos sobre embalses ofrecidos por la ACA (Agencia Catalana del Agua) http://aca.gencat.cat/ca/laigua/consulta-de-dades/dades-obertes/ . Es un ejemplo de buenas pr\u00e1cticas porque est\u00e1 bien documentado y contiene ejemplos. El acceso es libre y gratuito y tiene salida en un mapa para los ususarios que no sean desarrolladores. Ejemplo de salida http://aca-web.gencat.cat/sdim2/apirest/catalog?componentType=embassament Si bien el formato de salida es un JSON donde tiene una propiedad location no es un formato geogr\u00e1fico que podamos utilizar directamente para poner en un mapa, para ello tendr\u00edamos que hacer una transformaci\u00f3n hacia alg\u00fan formato geogr\u00e1fico tipo GeoJSON. Ejemplo de \"malas\" pr\u00e1cticas El servicio de la DIBA https://www.diba.cat/es/web/smartregion/premis-apps-iot-for-citizens/obtenir-acces-a-sentilo-diba ya que para acceder a los servicios es necesaria una API Key y para obtenerla hay que enviar un email con nuestros datos y el motivo de uso. El simple hecho de tener que registrarse ya es una barrera. El acceso a la aplicaci\u00f3n http://sentilo.diba.cat/sentilo-catalog-web/ no es f\u00e1cil de encontrar y no hay ninguna documentaci\u00f3n. Referencias http://www.opengeospatial.org/standards/sos \u21a9","title":"11. Consideraciones sobre servicios de Sensores"},{"location":"11_consideraciones_servicios_realtime_sensores/#consideraciones-sobre-servicios-de-sensores","text":"","title":"Consideraciones sobre servicios de Sensores"},{"location":"11_consideraciones_servicios_realtime_sensores/#problemas-frecuentes-al-trabajar-con-sensores","text":"Existe el estandar SOS de la OGC 1 , pero tiene poca implementaci\u00f3n, debido a que algunos de los fabricantes de sensores utilizan formatos propios, lo que dificulta la integraci\u00f3n de sensores de diferentes provedores en un s\u00f3lo sistema. Datos err\u00f3neos y falsos, ya sea por una mala lectura \u00f3 porque el sensor no est\u00e1 funcionando correctamente. No tenemos forma de saber si el dato es correcto. Ejemplo","title":"Problemas frecuentes al trabajar con sensores"},{"location":"11_consideraciones_servicios_realtime_sensores/#ejemplo-de-buenas-practicas","text":"El servicio de datos sobre embalses ofrecidos por la ACA (Agencia Catalana del Agua) http://aca.gencat.cat/ca/laigua/consulta-de-dades/dades-obertes/ . Es un ejemplo de buenas pr\u00e1cticas porque est\u00e1 bien documentado y contiene ejemplos. El acceso es libre y gratuito y tiene salida en un mapa para los ususarios que no sean desarrolladores. Ejemplo de salida http://aca-web.gencat.cat/sdim2/apirest/catalog?componentType=embassament Si bien el formato de salida es un JSON donde tiene una propiedad location no es un formato geogr\u00e1fico que podamos utilizar directamente para poner en un mapa, para ello tendr\u00edamos que hacer una transformaci\u00f3n hacia alg\u00fan formato geogr\u00e1fico tipo GeoJSON.","title":"Ejemplo de buenas pr\u00e1cticas"},{"location":"11_consideraciones_servicios_realtime_sensores/#ejemplo-de-malas-practicas","text":"El servicio de la DIBA https://www.diba.cat/es/web/smartregion/premis-apps-iot-for-citizens/obtenir-acces-a-sentilo-diba ya que para acceder a los servicios es necesaria una API Key y para obtenerla hay que enviar un email con nuestros datos y el motivo de uso. El simple hecho de tener que registrarse ya es una barrera. El acceso a la aplicaci\u00f3n http://sentilo.diba.cat/sentilo-catalog-web/ no es f\u00e1cil de encontrar y no hay ninguna documentaci\u00f3n.","title":"Ejemplo de \"malas\" pr\u00e1cticas"},{"location":"11_consideraciones_servicios_realtime_sensores/#referencias","text":"http://www.opengeospatial.org/standards/sos \u21a9","title":"Referencias"},{"location":"12_ejemplo_sensores_port_bcn/","text":"Ejemplo sensores port Barcelona Acceso al servicio de datos de sensores del Port de Barcelona En el portal de sensores del Port de Barcelona 1 podemos encontrar una serie de componentes gr\u00e1ficos o widgets que permiten acceder a los datos de los diferentes sensores SOS 2 . Tambi\u00e9n podemos acceder directamente al servicio http://sensors.portdebarcelona.cat/sos/json si queremos implementar nuestros propios componentes o procesar los datos directamente. En la documentaci\u00f3n del servicio vemos que estos widgets implementan un cliente SOS que soporta la versi\u00f3n 2.0 de est\u00e1ndard. Los widgets necesitan un endpoint en formato JSON. Lo cual resulta no ser un requisito del est\u00e1ndar si no una funcionalidad opcional que proporciona la implementaci\u00f3n del servidor SOS de 52 north en su versi\u00f3n 4.0.0 o superior. La ventaja de utilizar los widgets es que proporcionan una capa de abstracci\u00f3n que hace el \"trabajo sucio\" y evita trabajar directamente con el servicio. La implementaci\u00f3n de los widgets es open source 3 y extensible, lo que permite poder desarrollar nuestros propios widgets. Creaci\u00f3n de un visor Para crear un visor de mapas utilizaremos el widget de Mapa 4 que est\u00e1 basado en la librer\u00eda de mapas Leaflet. 5 Crear una carpeta con el nombre de visor-port . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [], \"properties\" : [] }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que carga un mapa del mundo. Este mapa no contiene ninguna informaci\u00f3n. Agregar algunas features (sensores) en la matriz de features. Para obtenter las features tendr\u00edamos que hacer una petici\u00f3n de GetFeatureOfInterest 6 . Para agregar algunos elementos en el mapa reemplazar la propiedad features por lo siguiente: <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [] }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar el mapa y confirmar que aparecen unos puntos en el puerto de Barcelona. Agregar propiedades a los sensores. Ya tenemos algunos sensores en nuestro mapa pero no tenemos datos asociados a los mismos. Para ello indicar que propiedades queremos observar. Esto lo indicaremos en la matriz de properties de nuestro mapa. Agregar las siguientes propiedades para ver la temperatura <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar el mapa y pasar el cursor sobre alg\u00fan elemento para ver que se despliega un panel con las temperaturas. Combinar varios widgets en la aplicaci\u00f3n. Mostar un popup con un widget al hacer click sobre un elemento. Utilizar la opci\u00f3n popup_widget del mapa. Cargar un widget de tipo serie de tiempo con las temperaturas. Escribir justo debajo de las propertities lo siguiente: <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"popup_widget\" : { \"name\" : \"timechart\" , \"title\" : \"Temperatures\" , \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"time_start\" : \"2015-09-03T05:05:40Z\" , \"time_end\" : \"2015-09-03T08:05:40Z\" } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar la p\u00e1gina y clicar sobre un elemento para ver un popup con la serie temporal de las temperaturas. Mostrar un widget en un div fuera del mapa al hacer click sobre un elemento. Escribir justo debajo de donde declaramos el div del mapa lo siguiente <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"popup_widget\" : { \"name\" : \"timechart\" , \"title\" : \"Temperatures\" , \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"time_start\" : \"2015-09-03T05:05:40Z\" , \"time_end\" : \"2015-09-03T08:05:40Z\" } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Crear un nuevo estilo para este div. Escibir en nuestro apartado de estilo css <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"popup_widget\" : { \"name\" : \"timechart\" , \"title\" : \"Temperatures\" , \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"time_start\" : \"2015-09-03T05:05:40Z\" , \"time_end\" : \"2015-09-03T08:05:40Z\" } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Quitar la opci\u00f3n de popup_widget del mapa. <!DOCTYPE html> <html> <head> <title>Sensores Port de Barcelona</title> <style> #map-container { position: absolute; top: 0; left: 0; bottom: 0; right: 0; } #info-container { position: absolute; top: 0; left: 0; width: \"200px\"; z-index: 9000; background-color: rgba(255,255,255,0.7); } </style> </head> <body> <div id=\"map-container\"></div> <div id=\"info-container\"></div> <script src=\"http://sensors.fonts.cat/js/SensorWidgets.js\"></script> <script type=\"text/javascript\"> SensorWidget('map', { \"service\": \"http://sensors.portdebarcelona.cat/sos/json\", \"offering\": \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\", \"swap_axis\": true, \"features\": [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\", \"http://sensors.portdebarcelona.cat/def/weather/features#02\", \"http://sensors.portdebarcelona.cat/def/weather/features#03\", \"http://sensors.portdebarcelona.cat/def/weather/features#P4\", \"http://sensors.portdebarcelona.cat/def/weather/features#10\", \"http://sensors.portdebarcelona.cat/def/weather/features#P5\", \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\": [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\", \"http://sensors.portdebarcelona.cat/def/weather/properties#32\", \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], - \"popup_widget\": { - \"name\": \"timechart\", - \"title\": \"Temperatures\", - \"properties\": [ - \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\", - \"http://sensors.portdebarcelona.cat/def/weather/properties#32\", - \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" - ], - \"time_start\": \"2015-09-03T05:05:40Z\", - \"time_end\": \"2015-09-03T08:05:40Z\" - } }, document.getElementById('map-container')); </script> </body> </html> Utilizar la opci\u00f3n de on_click del mapa. Esta opci\u00f3n permite definir una funci\u00f3n que se ejecuta al hacer click sobre un elemento del mapa. Copiar debajo de las properties lo siguiente: <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"on_click\" : function ( el ){ console . log ( el ); } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar la p\u00e1gina y clicar sobre un elemento. Abrir la consola de desarrollador para ver que aparece la informaci\u00f3n del elemento clicado. Crear una funci\u00f3n que recibe como par\u00e1metro el id de un elemento y crea un widget de tipo term\u00f3metro. Escribir antes de donde se cierra el tag de script <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"on_click\" : function ( el ){ console . log ( el ); } }, document . getElementById ( 'map-container' )); function showTermometro ( feature_id ){ SensorWidget ( 'thermometer' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"feature\" : feature_id , \"property\" : \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"refresh_interval\" : 120 , \"footnote\" : \"A sample footnote for Thermometer widget\" }, document . getElementById ( 'info-container' )); } </ script > </ body > </ html > Llamar a la nueva funci\u00f3n showTermometro dentro de la funci\u00f3n del on_click . Escribir luego del console.log <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"on_click\" : function ( el ){ console . log ( el ); showTermometro ( el . feature . id ); } }, document . getElementById ( 'map-container' )); function showTermometro ( feature_id ){ SensorWidget ( 'thermometer' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"feature\" : feature_id , \"property\" : \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"refresh_interval\" : 120 , \"footnote\" : \"A sample footnote for Thermometer widget\" }, document . getElementById ( 'info-container' )); } </ script > </ body > </ html > Recargar el mapa y clicar sobre un elemento para ver como se desplega el widget del term\u00f3metro con la temperatura actual. mapa de sensores del port de barcelona Ejercicio Crear una funci\u00f3n para mostrar el widget de man\u00f3metro en lugar del term\u00f3metro. Llamar esta nueva funci\u00f3n al hacer click sobre un sensor. En el siguiente enlace se pueden ver las diferentes opciones http://sensors.portdebarcelona.cat/?lang=es#gauge Referencias http://sensors.portdebarcelona.cat/?lang=es \u21a9 http://sensor-widgets.readthedocs.io/es/latest/sos.html \u21a9 https://github.com/oscarfonts/sensor-widgets \u21a9 http://sensor-widgets.readthedocs.io/es/latest/widgets.html#mapa-map \u21a9 http://leafletjs.com/ \u21a9 http://sensor-widgets.readthedocs.io/es/latest/sos.html#getfeatureofinterest \u21a9","title":"Ejemplo sensores port Barcelona"},{"location":"12_ejemplo_sensores_port_bcn/#ejemplo-sensores-port-barcelona","text":"","title":"Ejemplo sensores port Barcelona"},{"location":"12_ejemplo_sensores_port_bcn/#acceso-al-servicio-de-datos-de-sensores-del-port-de-barcelona","text":"En el portal de sensores del Port de Barcelona 1 podemos encontrar una serie de componentes gr\u00e1ficos o widgets que permiten acceder a los datos de los diferentes sensores SOS 2 . Tambi\u00e9n podemos acceder directamente al servicio http://sensors.portdebarcelona.cat/sos/json si queremos implementar nuestros propios componentes o procesar los datos directamente. En la documentaci\u00f3n del servicio vemos que estos widgets implementan un cliente SOS que soporta la versi\u00f3n 2.0 de est\u00e1ndard. Los widgets necesitan un endpoint en formato JSON. Lo cual resulta no ser un requisito del est\u00e1ndar si no una funcionalidad opcional que proporciona la implementaci\u00f3n del servidor SOS de 52 north en su versi\u00f3n 4.0.0 o superior. La ventaja de utilizar los widgets es que proporcionan una capa de abstracci\u00f3n que hace el \"trabajo sucio\" y evita trabajar directamente con el servicio. La implementaci\u00f3n de los widgets es open source 3 y extensible, lo que permite poder desarrollar nuestros propios widgets.","title":"Acceso al servicio de datos de sensores del Port de Barcelona"},{"location":"12_ejemplo_sensores_port_bcn/#creacion-de-un-visor","text":"Para crear un visor de mapas utilizaremos el widget de Mapa 4 que est\u00e1 basado en la librer\u00eda de mapas Leaflet. 5 Crear una carpeta con el nombre de visor-port . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [], \"properties\" : [] }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que carga un mapa del mundo. Este mapa no contiene ninguna informaci\u00f3n. Agregar algunas features (sensores) en la matriz de features. Para obtenter las features tendr\u00edamos que hacer una petici\u00f3n de GetFeatureOfInterest 6 . Para agregar algunos elementos en el mapa reemplazar la propiedad features por lo siguiente: <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [] }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar el mapa y confirmar que aparecen unos puntos en el puerto de Barcelona. Agregar propiedades a los sensores. Ya tenemos algunos sensores en nuestro mapa pero no tenemos datos asociados a los mismos. Para ello indicar que propiedades queremos observar. Esto lo indicaremos en la matriz de properties de nuestro mapa. Agregar las siguientes propiedades para ver la temperatura <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar el mapa y pasar el cursor sobre alg\u00fan elemento para ver que se despliega un panel con las temperaturas. Combinar varios widgets en la aplicaci\u00f3n. Mostar un popup con un widget al hacer click sobre un elemento. Utilizar la opci\u00f3n popup_widget del mapa. Cargar un widget de tipo serie de tiempo con las temperaturas. Escribir justo debajo de las propertities lo siguiente: <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"popup_widget\" : { \"name\" : \"timechart\" , \"title\" : \"Temperatures\" , \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"time_start\" : \"2015-09-03T05:05:40Z\" , \"time_end\" : \"2015-09-03T08:05:40Z\" } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar la p\u00e1gina y clicar sobre un elemento para ver un popup con la serie temporal de las temperaturas. Mostrar un widget en un div fuera del mapa al hacer click sobre un elemento. Escribir justo debajo de donde declaramos el div del mapa lo siguiente <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"popup_widget\" : { \"name\" : \"timechart\" , \"title\" : \"Temperatures\" , \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"time_start\" : \"2015-09-03T05:05:40Z\" , \"time_end\" : \"2015-09-03T08:05:40Z\" } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Crear un nuevo estilo para este div. Escibir en nuestro apartado de estilo css <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"popup_widget\" : { \"name\" : \"timechart\" , \"title\" : \"Temperatures\" , \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"time_start\" : \"2015-09-03T05:05:40Z\" , \"time_end\" : \"2015-09-03T08:05:40Z\" } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Quitar la opci\u00f3n de popup_widget del mapa. <!DOCTYPE html> <html> <head> <title>Sensores Port de Barcelona</title> <style> #map-container { position: absolute; top: 0; left: 0; bottom: 0; right: 0; } #info-container { position: absolute; top: 0; left: 0; width: \"200px\"; z-index: 9000; background-color: rgba(255,255,255,0.7); } </style> </head> <body> <div id=\"map-container\"></div> <div id=\"info-container\"></div> <script src=\"http://sensors.fonts.cat/js/SensorWidgets.js\"></script> <script type=\"text/javascript\"> SensorWidget('map', { \"service\": \"http://sensors.portdebarcelona.cat/sos/json\", \"offering\": \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\", \"swap_axis\": true, \"features\": [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\", \"http://sensors.portdebarcelona.cat/def/weather/features#02\", \"http://sensors.portdebarcelona.cat/def/weather/features#03\", \"http://sensors.portdebarcelona.cat/def/weather/features#P4\", \"http://sensors.portdebarcelona.cat/def/weather/features#10\", \"http://sensors.portdebarcelona.cat/def/weather/features#P5\", \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\": [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\", \"http://sensors.portdebarcelona.cat/def/weather/properties#32\", \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], - \"popup_widget\": { - \"name\": \"timechart\", - \"title\": \"Temperatures\", - \"properties\": [ - \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\", - \"http://sensors.portdebarcelona.cat/def/weather/properties#32\", - \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" - ], - \"time_start\": \"2015-09-03T05:05:40Z\", - \"time_end\": \"2015-09-03T08:05:40Z\" - } }, document.getElementById('map-container')); </script> </body> </html> Utilizar la opci\u00f3n de on_click del mapa. Esta opci\u00f3n permite definir una funci\u00f3n que se ejecuta al hacer click sobre un elemento del mapa. Copiar debajo de las properties lo siguiente: <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"on_click\" : function ( el ){ console . log ( el ); } }, document . getElementById ( 'map-container' )); </ script > </ body > </ html > Recargar la p\u00e1gina y clicar sobre un elemento. Abrir la consola de desarrollador para ver que aparece la informaci\u00f3n del elemento clicado. Crear una funci\u00f3n que recibe como par\u00e1metro el id de un elemento y crea un widget de tipo term\u00f3metro. Escribir antes de donde se cierra el tag de script <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"on_click\" : function ( el ){ console . log ( el ); } }, document . getElementById ( 'map-container' )); function showTermometro ( feature_id ){ SensorWidget ( 'thermometer' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"feature\" : feature_id , \"property\" : \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"refresh_interval\" : 120 , \"footnote\" : \"A sample footnote for Thermometer widget\" }, document . getElementById ( 'info-container' )); } </ script > </ body > </ html > Llamar a la nueva funci\u00f3n showTermometro dentro de la funci\u00f3n del on_click . Escribir luego del console.log <!DOCTYPE html> < html > < head > < title > Sensores Port de Barcelona </ title > < style > # map-container { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } # info-container { position : absolute ; top : 0 ; left : 0 ; width : \"200px\" ; z-index : 9000 ; background-color : rgba ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < div id = \"map-container\" ></ div > < div id = \"info-container\" ></ div > < script src = \"http://sensors.fonts.cat/js/SensorWidgets.js\" ></ script > < script type = \"text/javascript\" > SensorWidget ( 'map' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"swap_axis\" : true , \"features\" : [ \"http://sensors.portdebarcelona.cat/def/weather/features#01\" , \"http://sensors.portdebarcelona.cat/def/weather/features#02\" , \"http://sensors.portdebarcelona.cat/def/weather/features#03\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P4\" , \"http://sensors.portdebarcelona.cat/def/weather/features#10\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P5\" , \"http://sensors.portdebarcelona.cat/def/weather/features#P6\" ], \"properties\" : [ \"http://sensors.portdebarcelona.cat/def/weather/properties#32M\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"http://sensors.portdebarcelona.cat/def/weather/properties#32N\" ], \"on_click\" : function ( el ){ console . log ( el ); showTermometro ( el . feature . id ); } }, document . getElementById ( 'map-container' )); function showTermometro ( feature_id ){ SensorWidget ( 'thermometer' , { \"service\" : \"http://sensors.portdebarcelona.cat/sos/json\" , \"offering\" : \"http://sensors.portdebarcelona.cat/def/weather/offerings#30m\" , \"feature\" : feature_id , \"property\" : \"http://sensors.portdebarcelona.cat/def/weather/properties#32\" , \"refresh_interval\" : 120 , \"footnote\" : \"A sample footnote for Thermometer widget\" }, document . getElementById ( 'info-container' )); } </ script > </ body > </ html > Recargar el mapa y clicar sobre un elemento para ver como se desplega el widget del term\u00f3metro con la temperatura actual. mapa de sensores del port de barcelona Ejercicio Crear una funci\u00f3n para mostrar el widget de man\u00f3metro en lugar del term\u00f3metro. Llamar esta nueva funci\u00f3n al hacer click sobre un sensor. En el siguiente enlace se pueden ver las diferentes opciones http://sensors.portdebarcelona.cat/?lang=es#gauge","title":"Creaci\u00f3n de un visor"},{"location":"12_ejemplo_sensores_port_bcn/#referencias","text":"http://sensors.portdebarcelona.cat/?lang=es \u21a9 http://sensor-widgets.readthedocs.io/es/latest/sos.html \u21a9 https://github.com/oscarfonts/sensor-widgets \u21a9 http://sensor-widgets.readthedocs.io/es/latest/widgets.html#mapa-map \u21a9 http://leafletjs.com/ \u21a9 http://sensor-widgets.readthedocs.io/es/latest/sos.html#getfeatureofinterest \u21a9","title":"Referencias"},{"location":"13_ejemplo_sentilo_aca/","text":"Ejemplo Sentilo ACA Acceso al servicio de sensores Sentilo de la ACA En el apartado de consulta de datos de la p\u00e1gina de la ACA 1 encontraremos un subapartado de datos en tiempo real, estos datos los sirven utilizando la plataforma de sensores Sentilo 2 . Los sensores dan informaci\u00f3n sobre los diferentes embalses/pantanos que hay en Catalu\u00f1a. La p\u00e1gina tiene un acceso a un mapa con los datos de los diferentes sensores 3 este mapa es el que ofrece la plataforma de Sentilo y est\u00e1 basado en tecnolog\u00eda de Google Maps. Tambi\u00e9n encontraremos la documentaci\u00f3n 4 para usar la API, lo que nos permite acceder a los datos y generar nuestro propio visor. Creaci\u00f3n de un visor Para crear un visor de mapas utilizaremos la librer\u00eda de mapas Leaflet 5 . Crear una carpeta con el nombre de visor-aca . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que se carga un mapa centrado en Catalu\u00f1a. Consultar la documentaci\u00f3n de la API y buscar la url de descripci\u00f3n del servicio que es http://aca-web.gencat.cat/sdim2/apirest/catalog . Abrir esta url en el navegador y confirmar que responde un JSON con la informaci\u00f3n de los diferentes sensores. Revisar el JSON de salida y buscar la propiedad location que indica las coordenadas de la ubicaci\u00f3n del sensor. A pesar de que el JSON tiene coordenadas no es un GeoJSON y por lo tanto no lo podemos pintar autom\u00e1ticamente en nuestro mapa. Cargar este JSON en nuestro mapa utilizando un plugin de Leaflet llamado leaflet-ajax 6 . Este plugin permite hacer una llamada AJAX a un servicio que retorne un JSON y cargar la respuesta en un mapa. Para cargar este plugin debemos agregar lo siguiente justo despu\u00e9s de donde hemos cargado el leaflet <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Utilizar el plugin para agregar la capa al mapa llamando a la API de la ACA. Agregar lo siguiente al final de nuestro c\u00f3digo: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina y confirmar que no aparece ninguna informaci\u00f3n en el mapa. Abrir la consola de desarrollador del navegador (Ctrl+F12) para ver que aparece un mensaje de error XMLHttpRequest cannot load ... ello es debido a que estamos llamando a un servicio que no est\u00e1 en nuestro dominio y por lo tanto da un error de CORS 7 . Para evitar el error de CORS necesitamos un proxy 8 en nuestro servidor web que pueda hacer la llamada al servicio de la ACA y que nos devuelva el contenido. Creaci\u00f3n del proxy Instalar Node.js 9 . Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 12.13.1 LTS) y lo instalaremos con las opciones por defecto. Abrir la consola para verificar que se ha instalado correctamente y escribir node -v Navegar hasta nuestra carpeta visor-aca y escribir: npm init Con este comando estaremos creando el archivo package.json , el cual solicita varios elementos como por ejemplo; el nombre y la versi\u00f3n de la aplicaci\u00f3n. Por ahora, s\u00f3lo hay que pulsar ENTER para aceptar los valores predeterminados. Instalar las dependencias para crear nuestro servicio de proxy. En este caso utilizaremos Express 10 como servidor web y el m\u00f3dulo http-proxy 11 . Instalar el express y guardarlo en la lista de dependencias npm install express --save Instalar el http-proxy y guardarlo en la lista de dependencias npm install http-proxy --save Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que servir\u00e1 de proxy con el servicio de la ACA. Copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var httpProxy = require ( 'http-proxy' ); var apiProxy = httpProxy . createProxyServer (); var serverAca = 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/aca/*\" , function ( req , res ) { console . log ( 'redirecting to Server1' ); apiProxy . web ( req , res , { target : serverAca , changeOrigin : false , ignorePath : true }); }); app . listen ( 3000 ); Probar que nuestro proxy est\u00e1 funcionando, escribir: node app.js Abrir la url de nuestro proxy http://localhost:3000/aca/ en el navegador. Escribir en el navegador http://localhost:3000 y ver nuestro mapa. Modificar el mapa Modificar el archivo index.html para que llame al proxy que hemos creado. Cambiar la url de la capa geojsonLayer http://aca-web.gencat.cat/sdim2/apirest/catalog por nuestro proxy http://localhost:3000/aca/ (como el proxy y la aplicaci\u00f3n est\u00e1n en el mismo servidor podr\u00edamos usar /aca/ ). <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' ). addTo ( map ); </ script > </ body > </ html > Recargar la aplicaci\u00f3n con Ctrl+F5 y vemos que el error ha desaparecido. Continuaremos sin ver ning\u00fan dato en nuestro mapa. Esto es debido a lo que ya mencionamos; que la API no retorna un GeoJSON. Por lo tanto tendremos que convertir la respuesta de la API en un GeoJSON. Convertir la respuesta en un GeoJSON utilizando la opci\u00f3n middleware que ofrece la capa GeoJSON.AJAX. Esta opci\u00f3n permite crear una funcion donde se pueden manipular los datos antes de agregarlos al mapa. Crear la funci\u00f3n que transforma los datos de Sentilo de la ACA en un GeoJSON. Escribir al final de nuestro c\u00f3digo <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' ). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } </ script > </ body > </ html > Modficar la capa geojsonLayer para que el middleware llame a nuestra funci\u00f3n de transformaci\u00f3n. Cambiar el c\u00f3digo de la capa por lo siguiente: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } </ script > </ body > </ html > Recargar el mapa y ver los puntos de los embalses en el mapa. Mostrar la informaci\u00f3n del punto. Agregar el evento click en cada unos de los puntos. Utilizar la opci\u00f3n de onEachFeature que ofrece las capa GeoJSON de Leaflet. Esta opci\u00f3n permite ejecutar una funci\u00f3n en la creaci\u00f3n de cada uno de los elementos de la capa. Es muy \u00fatil para agregar popups a los elementos \u00f3 para agregar eventos en los elementos. Crear una funci\u00f3n llamada eachFeature que recibe como par\u00e1metros un feature (elemento del GeoJSON) y un layer (elemento de Leaflet). La funci\u00f3n ser\u00eda la siguiente <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ console . log ( f ); console . log ( l ); }); } </ script > </ body > </ html > Llamar a la funcion eachFeature en la opci\u00f3n onEachFeature de la capa geojsonLayer. Escribir lo siguiente luego de la opci\u00f3n del middleware <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ console . log ( f ); console . log ( l ); }); } </ script > </ body > </ html > Recargar el mapa y hacer click sobre un elemento. En la consola de desarrollador ver que aparecen 2 entradas una que corresponde al feature y otra al layer. Llamar a la API de la ACA para pedir la \u00faltima lectura del sensor y as\u00ed obtener la informaci\u00f3n. La url para obtener la \u00faltima lectura es http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST . . /lastOb/. Por ejemplo: http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST.082687-001/lastOb/ Como estamos llamando una url que est\u00e1 fuera de nuestro dominio tenemos el mismo problema de CORS. Modificar el proxy Modificar nuestro proxy para obtener la informaci\u00f3n de un sensor. Escribir en nuestro archivo app.js justo debajo de la declaraci\u00f3n de la variable serverAca var express = require ( 'express' ); var app = express (); var httpProxy = require ( 'http-proxy' ); var apiProxy = httpProxy . createProxyServer (); var serverAca = 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ; var serverAcaLastOb = 'http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST.' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/aca/*\" , function ( req , res ) { console . log ( 'redirecting to Server1' ); apiProxy . web ( req , res , { target : serverAca , changeOrigin : false , ignorePath : true }); }); app . listen ( 3000 ); Agregar justo antes del app.listen el c\u00f3digo que nos va a ser de proxy. var express = require ( 'express' ); var app = express (); var httpProxy = require ( 'http-proxy' ); var apiProxy = httpProxy . createProxyServer (); var serverAca = 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ; var serverAcaLastOb = 'http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST.' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/aca/*\" , function ( req , res ) { console . log ( 'redirecting to Server1' ); apiProxy . web ( req , res , { target : serverAca , changeOrigin : false , ignorePath : true }); }); app . all ( \"/acalast/:id\" , function ( req , res ){ console . log ( 'redirecting to Server2' + req . params . id ); apiProxy . web ( req , res , { target : serverAcaLastOb + req . params . id + '/lastOb/' , changeOrigin : false , ignorePath : true }); }); app . listen ( 3000 ); Reiniciar nuestro servidor de node, ir a la consola y presionar Crtl+c. Escribir node app.js. Abrir la url http://localhost:3000/acalast/082687-001 en el navegador para comprobar que el proxy est\u00e1 funcionando correctamente. Modificar la funci\u00f3n que se llama al hacer click sobre un elemento del mapa para que llame a nuestro proxy. Esta funci\u00f3n ejecutar\u00e1 una llamada ajax al proxy. Modificar la funci\u00f3n eachFeature con el siguiente c\u00f3digo <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ var url = 'http://localhost:3000/acalast/' + f . properties . id ; fetch ( url ) . then ( function ( response ) { response . json (). then ( function ( data ){ console . log ( data ); }); }) . catch ( function ( myJson ) { console . log ( myJson ); }); }); } </ script > </ body > </ html > Recargar el mapa y hacer click sobre un elemento para ver que en la consola del desarrollador aparece un objeto que contiene la respuesa del sensor con la informaci\u00f3n de la \u00faltima lectura. Crear una funci\u00f3n llamada popUp para mostrar esta informaci\u00f3n en el mapa. La funci\u00f3n recibe como par\u00e1metros un layer de Leaflet y unos datos del sensor. Esta funci\u00f3n muestra un popup asociado al elemento con la informaci\u00f3n del sensor. Escribir despu\u00e9s de la funci\u00f3n eachFeature <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ var url = 'http://localhost:3000/acalast/' + f . properties . id ; fetch ( url ) . then ( function ( response ) { response . json (). then ( function ( data ){ console . log ( data ); }); }) . catch ( function ( myJson ) { console . log ( myJson ); }); }); } function popUp ( l , data ){ var out = []; out . push ( '<strong>' + data . componentDesc + '</strong>' ); if ( data . sensorLastObservations ){ for ( var i = data . sensorLastObservations . length - 1 ; i >= 0 ; i -- ) { var observ = data . sensorLastObservations [ i ]; out . push ( observ . sensorType + \": \" + observ . value + \" \" + observ . unit ); } } l . unbindPopup (); l . bindPopup ( out . join ( \"<br />\" )). togglePopup (); } </ script > </ body > </ html > Llamar a la funci\u00f3n popUp dentro de la funci\u00f3n que se llama en el success de la llamada ajax. Escribir <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ var url = 'http://localhost:3000/acalast/' + f . properties . id ; fetch ( url ) . then ( function ( response ) { response . json (). then ( function ( data ){ popUp ( l , data ); }); }) . catch ( function ( myJson ) { console . log ( myJson ); }); }); } function popUp ( l , data ){ var out = []; out . push ( '<strong>' + data . componentDesc + '</strong>' ); if ( data . sensorLastObservations ){ for ( var i = data . sensorLastObservations . length - 1 ; i >= 0 ; i -- ) { var observ = data . sensorLastObservations [ i ]; out . push ( observ . sensorType + \": \" + observ . value + \" \" + observ . unit ); } } l . unbindPopup (); l . bindPopup ( out . join ( \"<br />\" )). togglePopup (); } </ script > </ body > </ html > Recargar la aplicaci\u00f3n y clicar sobre un elemento. Debe aparecer un popup con la informaci\u00f3n de la \u00faltima lectura del sensor. ejemplo sentilo ACA Referencias http://aca.gencat.cat/ca/laigua/consulta-de-dades/dades-obertes/ \u21a9 http://www.sentilo.io/wordpress/ \u21a9 http://aca-web.gencat.cat/sentilo-catalog-web/component/map \u21a9 http://aca.gencat.cat/web/.content/20_Aigua/08_consulta_de_dades/01_dades_obertes/us_serveis_dades_API_REST.pdf \u21a9 http://leafletjs.com/ \u21a9 https://github.com/calvinmetcalf/leaflet-ajax \u21a9 https://developer.mozilla.org/es/docs/Web/HTTP/Access_control_CORS \u21a9 https://es.wikipedia.org/wiki/Servidor_proxy \u21a9 https://nodejs.org/es/ \u21a9 http://expressjs.com/ \u21a9 https://github.com/nodejitsu/node-http-proxy \u21a9","title":"12. Ejemplo Sentilo ACA"},{"location":"13_ejemplo_sentilo_aca/#ejemplo-sentilo-aca","text":"","title":"Ejemplo Sentilo ACA"},{"location":"13_ejemplo_sentilo_aca/#acceso-al-servicio-de-sensores-sentilo-de-la-aca","text":"En el apartado de consulta de datos de la p\u00e1gina de la ACA 1 encontraremos un subapartado de datos en tiempo real, estos datos los sirven utilizando la plataforma de sensores Sentilo 2 . Los sensores dan informaci\u00f3n sobre los diferentes embalses/pantanos que hay en Catalu\u00f1a. La p\u00e1gina tiene un acceso a un mapa con los datos de los diferentes sensores 3 este mapa es el que ofrece la plataforma de Sentilo y est\u00e1 basado en tecnolog\u00eda de Google Maps. Tambi\u00e9n encontraremos la documentaci\u00f3n 4 para usar la API, lo que nos permite acceder a los datos y generar nuestro propio visor.","title":"Acceso al servicio de sensores Sentilo de la ACA"},{"location":"13_ejemplo_sentilo_aca/#creacion-de-un-visor","text":"Para crear un visor de mapas utilizaremos la librer\u00eda de mapas Leaflet 5 . Crear una carpeta con el nombre de visor-aca . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que se carga un mapa centrado en Catalu\u00f1a. Consultar la documentaci\u00f3n de la API y buscar la url de descripci\u00f3n del servicio que es http://aca-web.gencat.cat/sdim2/apirest/catalog . Abrir esta url en el navegador y confirmar que responde un JSON con la informaci\u00f3n de los diferentes sensores. Revisar el JSON de salida y buscar la propiedad location que indica las coordenadas de la ubicaci\u00f3n del sensor. A pesar de que el JSON tiene coordenadas no es un GeoJSON y por lo tanto no lo podemos pintar autom\u00e1ticamente en nuestro mapa. Cargar este JSON en nuestro mapa utilizando un plugin de Leaflet llamado leaflet-ajax 6 . Este plugin permite hacer una llamada AJAX a un servicio que retorne un JSON y cargar la respuesta en un mapa. Para cargar este plugin debemos agregar lo siguiente justo despu\u00e9s de donde hemos cargado el leaflet <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Utilizar el plugin para agregar la capa al mapa llamando a la API de la ACA. Agregar lo siguiente al final de nuestro c\u00f3digo: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina y confirmar que no aparece ninguna informaci\u00f3n en el mapa. Abrir la consola de desarrollador del navegador (Ctrl+F12) para ver que aparece un mensaje de error XMLHttpRequest cannot load ... ello es debido a que estamos llamando a un servicio que no est\u00e1 en nuestro dominio y por lo tanto da un error de CORS 7 . Para evitar el error de CORS necesitamos un proxy 8 en nuestro servidor web que pueda hacer la llamada al servicio de la ACA y que nos devuelva el contenido.","title":"Creaci\u00f3n de un visor"},{"location":"13_ejemplo_sentilo_aca/#creacion-del-proxy","text":"Instalar Node.js 9 . Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 12.13.1 LTS) y lo instalaremos con las opciones por defecto. Abrir la consola para verificar que se ha instalado correctamente y escribir node -v Navegar hasta nuestra carpeta visor-aca y escribir: npm init Con este comando estaremos creando el archivo package.json , el cual solicita varios elementos como por ejemplo; el nombre y la versi\u00f3n de la aplicaci\u00f3n. Por ahora, s\u00f3lo hay que pulsar ENTER para aceptar los valores predeterminados. Instalar las dependencias para crear nuestro servicio de proxy. En este caso utilizaremos Express 10 como servidor web y el m\u00f3dulo http-proxy 11 . Instalar el express y guardarlo en la lista de dependencias npm install express --save Instalar el http-proxy y guardarlo en la lista de dependencias npm install http-proxy --save Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que servir\u00e1 de proxy con el servicio de la ACA. Copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var httpProxy = require ( 'http-proxy' ); var apiProxy = httpProxy . createProxyServer (); var serverAca = 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/aca/*\" , function ( req , res ) { console . log ( 'redirecting to Server1' ); apiProxy . web ( req , res , { target : serverAca , changeOrigin : false , ignorePath : true }); }); app . listen ( 3000 ); Probar que nuestro proxy est\u00e1 funcionando, escribir: node app.js Abrir la url de nuestro proxy http://localhost:3000/aca/ en el navegador. Escribir en el navegador http://localhost:3000 y ver nuestro mapa.","title":"Creaci\u00f3n del proxy"},{"location":"13_ejemplo_sentilo_aca/#modificar-el-mapa","text":"Modificar el archivo index.html para que llame al proxy que hemos creado. Cambiar la url de la capa geojsonLayer http://aca-web.gencat.cat/sdim2/apirest/catalog por nuestro proxy http://localhost:3000/aca/ (como el proxy y la aplicaci\u00f3n est\u00e1n en el mismo servidor podr\u00edamos usar /aca/ ). <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' ). addTo ( map ); </ script > </ body > </ html > Recargar la aplicaci\u00f3n con Ctrl+F5 y vemos que el error ha desaparecido. Continuaremos sin ver ning\u00fan dato en nuestro mapa. Esto es debido a lo que ya mencionamos; que la API no retorna un GeoJSON. Por lo tanto tendremos que convertir la respuesta de la API en un GeoJSON. Convertir la respuesta en un GeoJSON utilizando la opci\u00f3n middleware que ofrece la capa GeoJSON.AJAX. Esta opci\u00f3n permite crear una funcion donde se pueden manipular los datos antes de agregarlos al mapa. Crear la funci\u00f3n que transforma los datos de Sentilo de la ACA en un GeoJSON. Escribir al final de nuestro c\u00f3digo <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' ). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } </ script > </ body > </ html > Modficar la capa geojsonLayer para que el middleware llame a nuestra funci\u00f3n de transformaci\u00f3n. Cambiar el c\u00f3digo de la capa por lo siguiente: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } </ script > </ body > </ html > Recargar el mapa y ver los puntos de los embalses en el mapa. Mostrar la informaci\u00f3n del punto. Agregar el evento click en cada unos de los puntos. Utilizar la opci\u00f3n de onEachFeature que ofrece las capa GeoJSON de Leaflet. Esta opci\u00f3n permite ejecutar una funci\u00f3n en la creaci\u00f3n de cada uno de los elementos de la capa. Es muy \u00fatil para agregar popups a los elementos \u00f3 para agregar eventos en los elementos. Crear una funci\u00f3n llamada eachFeature que recibe como par\u00e1metros un feature (elemento del GeoJSON) y un layer (elemento de Leaflet). La funci\u00f3n ser\u00eda la siguiente <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ console . log ( f ); console . log ( l ); }); } </ script > </ body > </ html > Llamar a la funcion eachFeature en la opci\u00f3n onEachFeature de la capa geojsonLayer. Escribir lo siguiente luego de la opci\u00f3n del middleware <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ console . log ( f ); console . log ( l ); }); } </ script > </ body > </ html > Recargar el mapa y hacer click sobre un elemento. En la consola de desarrollador ver que aparecen 2 entradas una que corresponde al feature y otra al layer. Llamar a la API de la ACA para pedir la \u00faltima lectura del sensor y as\u00ed obtener la informaci\u00f3n. La url para obtener la \u00faltima lectura es http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST . . /lastOb/. Por ejemplo: http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST.082687-001/lastOb/ Como estamos llamando una url que est\u00e1 fuera de nuestro dominio tenemos el mismo problema de CORS.","title":"Modificar el mapa"},{"location":"13_ejemplo_sentilo_aca/#modificar-el-proxy","text":"Modificar nuestro proxy para obtener la informaci\u00f3n de un sensor. Escribir en nuestro archivo app.js justo debajo de la declaraci\u00f3n de la variable serverAca var express = require ( 'express' ); var app = express (); var httpProxy = require ( 'http-proxy' ); var apiProxy = httpProxy . createProxyServer (); var serverAca = 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ; var serverAcaLastOb = 'http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST.' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/aca/*\" , function ( req , res ) { console . log ( 'redirecting to Server1' ); apiProxy . web ( req , res , { target : serverAca , changeOrigin : false , ignorePath : true }); }); app . listen ( 3000 ); Agregar justo antes del app.listen el c\u00f3digo que nos va a ser de proxy. var express = require ( 'express' ); var app = express (); var httpProxy = require ( 'http-proxy' ); var apiProxy = httpProxy . createProxyServer (); var serverAca = 'http://aca-web.gencat.cat/sdim2/apirest/catalog' ; var serverAcaLastOb = 'http://aca-web.gencat.cat/sentilo-catalog-web/component/map/EMBASSAMENT-EST.' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/aca/*\" , function ( req , res ) { console . log ( 'redirecting to Server1' ); apiProxy . web ( req , res , { target : serverAca , changeOrigin : false , ignorePath : true }); }); app . all ( \"/acalast/:id\" , function ( req , res ){ console . log ( 'redirecting to Server2' + req . params . id ); apiProxy . web ( req , res , { target : serverAcaLastOb + req . params . id + '/lastOb/' , changeOrigin : false , ignorePath : true }); }); app . listen ( 3000 ); Reiniciar nuestro servidor de node, ir a la consola y presionar Crtl+c. Escribir node app.js. Abrir la url http://localhost:3000/acalast/082687-001 en el navegador para comprobar que el proxy est\u00e1 funcionando correctamente. Modificar la funci\u00f3n que se llama al hacer click sobre un elemento del mapa para que llame a nuestro proxy. Esta funci\u00f3n ejecutar\u00e1 una llamada ajax al proxy. Modificar la funci\u00f3n eachFeature con el siguiente c\u00f3digo <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ var url = 'http://localhost:3000/acalast/' + f . properties . id ; fetch ( url ) . then ( function ( response ) { response . json (). then ( function ( data ){ console . log ( data ); }); }) . catch ( function ( myJson ) { console . log ( myJson ); }); }); } </ script > </ body > </ html > Recargar el mapa y hacer click sobre un elemento para ver que en la consola del desarrollador aparece un objeto que contiene la respuesa del sensor con la informaci\u00f3n de la \u00faltima lectura. Crear una funci\u00f3n llamada popUp para mostrar esta informaci\u00f3n en el mapa. La funci\u00f3n recibe como par\u00e1metros un layer de Leaflet y unos datos del sensor. Esta funci\u00f3n muestra un popup asociado al elemento con la informaci\u00f3n del sensor. Escribir despu\u00e9s de la funci\u00f3n eachFeature <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ var url = 'http://localhost:3000/acalast/' + f . properties . id ; fetch ( url ) . then ( function ( response ) { response . json (). then ( function ( data ){ console . log ( data ); }); }) . catch ( function ( myJson ) { console . log ( myJson ); }); }); } function popUp ( l , data ){ var out = []; out . push ( '<strong>' + data . componentDesc + '</strong>' ); if ( data . sensorLastObservations ){ for ( var i = data . sensorLastObservations . length - 1 ; i >= 0 ; i -- ) { var observ = data . sensorLastObservations [ i ]; out . push ( observ . sensorType + \": \" + observ . value + \" \" + observ . unit ); } } l . unbindPopup (); l . bindPopup ( out . join ( \"<br />\" )). togglePopup (); } </ script > </ body > </ html > Llamar a la funci\u00f3n popUp dentro de la funci\u00f3n que se llama en el success de la llamada ajax. Escribir <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Sentilo ACA </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.5087 , 2.1777 ], 8 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( 'http://localhost:3000/aca/' , { middleware : function ( data ){ return sentiloAca2geoJSON ( data ); } , onEachFeature : eachFeature }). addTo ( map ); function sentiloAca2geoJSON ( data ){ var geojson = { type : \"FeatureCollection\" , features : [] }; var sensors = data . providers [ 0 ]. sensors ; for ( var i = sensors . length - 1 ; i >= 0 ; i -- ) { var sensor = sensors [ i ]; var location = sensor . location . split ( \" \" ); var feature = { type : 'Feature' , properties : { description : sensor . description , id : sensor . component , nom : sensor . componentDesc , info : sensor . componentAdditionalInfo , unit : sensor . unit }, geometry : { type : 'Point' , coordinates : [ location [ 1 ], location [ 0 ]] } }; geojson . features . push ( feature ); } return geojson ; } function eachFeature ( f , l ){ l . on ( 'click' , function ( ev ){ var url = 'http://localhost:3000/acalast/' + f . properties . id ; fetch ( url ) . then ( function ( response ) { response . json (). then ( function ( data ){ popUp ( l , data ); }); }) . catch ( function ( myJson ) { console . log ( myJson ); }); }); } function popUp ( l , data ){ var out = []; out . push ( '<strong>' + data . componentDesc + '</strong>' ); if ( data . sensorLastObservations ){ for ( var i = data . sensorLastObservations . length - 1 ; i >= 0 ; i -- ) { var observ = data . sensorLastObservations [ i ]; out . push ( observ . sensorType + \": \" + observ . value + \" \" + observ . unit ); } } l . unbindPopup (); l . bindPopup ( out . join ( \"<br />\" )). togglePopup (); } </ script > </ body > </ html > Recargar la aplicaci\u00f3n y clicar sobre un elemento. Debe aparecer un popup con la informaci\u00f3n de la \u00faltima lectura del sensor. ejemplo sentilo ACA","title":"Modificar el proxy"},{"location":"13_ejemplo_sentilo_aca/#referencias","text":"http://aca.gencat.cat/ca/laigua/consulta-de-dades/dades-obertes/ \u21a9 http://www.sentilo.io/wordpress/ \u21a9 http://aca-web.gencat.cat/sentilo-catalog-web/component/map \u21a9 http://aca.gencat.cat/web/.content/20_Aigua/08_consulta_de_dades/01_dades_obertes/us_serveis_dades_API_REST.pdf \u21a9 http://leafletjs.com/ \u21a9 https://github.com/calvinmetcalf/leaflet-ajax \u21a9 https://developer.mozilla.org/es/docs/Web/HTTP/Access_control_CORS \u21a9 https://es.wikipedia.org/wiki/Servidor_proxy \u21a9 https://nodejs.org/es/ \u21a9 http://expressjs.com/ \u21a9 https://github.com/nodejitsu/node-http-proxy \u21a9","title":"Referencias"},{"location":"14_geoservicios_realtime/","text":"Geoservicios realtime Muchos de los geoservicios m\u00e1s tradicionales como los WMS o WFS pueden ser Geoservicios realtime, siempre y cuando los datos que se sirvan sean actualizados constantemente. Un ejemplo de esto es el servicio WMS sobre el estado del tr\u00e1fico del Servei Catal\u00e0 de Tr\u00e0nsit http://transit.gencat.cat/ca/informacio_viaria/estat_del_transit/informacio_geografica/estat_del_transit/ Otro ejemplo de geoservicio o m\u00e1s bien geodatos en realtime ser\u00eda la capa de Tr\u00e1fico de Google Maps. https://developers.google.com/maps/documentation/javascript/3.exp/reference?hl=es-419#TrafficLayer Geocodificaci\u00f3n OpenCage Geocoder https://geocoder.opencagedata.com/ Servicios basados en OSM http://wiki.openstreetmap.org/wiki/Search_engines Routing Comparador de servicios basados en OSM http://wiki.openstreetmap.org/wiki/Routing/online_routers Is\u00f3cronas Servicios basados en OSM http://wiki.openstreetmap.org/wiki/Isochrone Servicios varios Servicios de la API de Google Maps https://developers.google.com/maps/web-services/?hl=es-419 Servicios de la API de Here https://developer.here.com/documentation Servicios de la API de MapQuest https://developer.mapquest.com/ Servicios de la API de ArcGis https://developers.arcgis.com/content-and-services/","title":"13. Geoservicios realtime"},{"location":"14_geoservicios_realtime/#geoservicios-realtime","text":"Muchos de los geoservicios m\u00e1s tradicionales como los WMS o WFS pueden ser Geoservicios realtime, siempre y cuando los datos que se sirvan sean actualizados constantemente. Un ejemplo de esto es el servicio WMS sobre el estado del tr\u00e1fico del Servei Catal\u00e0 de Tr\u00e0nsit http://transit.gencat.cat/ca/informacio_viaria/estat_del_transit/informacio_geografica/estat_del_transit/ Otro ejemplo de geoservicio o m\u00e1s bien geodatos en realtime ser\u00eda la capa de Tr\u00e1fico de Google Maps. https://developers.google.com/maps/documentation/javascript/3.exp/reference?hl=es-419#TrafficLayer","title":"Geoservicios realtime"},{"location":"14_geoservicios_realtime/#geocodificacion","text":"OpenCage Geocoder https://geocoder.opencagedata.com/ Servicios basados en OSM http://wiki.openstreetmap.org/wiki/Search_engines","title":"Geocodificaci\u00f3n"},{"location":"14_geoservicios_realtime/#routing","text":"Comparador de servicios basados en OSM http://wiki.openstreetmap.org/wiki/Routing/online_routers","title":"Routing"},{"location":"14_geoservicios_realtime/#isocronas","text":"Servicios basados en OSM http://wiki.openstreetmap.org/wiki/Isochrone","title":"Is\u00f3cronas"},{"location":"14_geoservicios_realtime/#servicios-varios","text":"Servicios de la API de Google Maps https://developers.google.com/maps/web-services/?hl=es-419 Servicios de la API de Here https://developer.here.com/documentation Servicios de la API de MapQuest https://developer.mapquest.com/ Servicios de la API de ArcGis https://developers.arcgis.com/content-and-services/","title":"Servicios varios"},{"location":"15_herramientas_visualizacion_geoservicios/","text":"Herramientas de visualizaci\u00f3n geoservicios Librerias Para la visualizaci\u00f3n de datos geogr\u00e1ficos en el la web existen diversas librerias, entre las principales podemos mencionar: http://leafletjs.com/ https://openlayers.org/ https://d3js.org/ https://developers.google.com/maps/?hl=es-419 https://www.mapbox.com/mapbox-gl-js/api/ Servicios Aparte de la librer\u00edas que permiten desarrollar nuestras propias aplicaciones, tambi\u00e9n podemos encontrar diferentes servicios que os ofrecen la posibilidad de crear o publicar nuestros mapas en la web de una forma r\u00e1pida y sencilla sin tener que programar. Estos servicios permiten hacer algunos an\u00e1lisis sobre nuestros datos. Entre los principales est\u00e1n: https://carto.com/ https://www.mapbox.com/ https://mangomap.com/ https://www.giscloud.com/ https://www.instamaps.cat/","title":"14. Herramientas de visualizaci\u00f3n geoservicios"},{"location":"15_herramientas_visualizacion_geoservicios/#herramientas-de-visualizacion-geoservicios","text":"","title":"Herramientas de visualizaci\u00f3n geoservicios"},{"location":"15_herramientas_visualizacion_geoservicios/#librerias","text":"Para la visualizaci\u00f3n de datos geogr\u00e1ficos en el la web existen diversas librerias, entre las principales podemos mencionar: http://leafletjs.com/ https://openlayers.org/ https://d3js.org/ https://developers.google.com/maps/?hl=es-419 https://www.mapbox.com/mapbox-gl-js/api/","title":"Librerias"},{"location":"15_herramientas_visualizacion_geoservicios/#servicios","text":"Aparte de la librer\u00edas que permiten desarrollar nuestras propias aplicaciones, tambi\u00e9n podemos encontrar diferentes servicios que os ofrecen la posibilidad de crear o publicar nuestros mapas en la web de una forma r\u00e1pida y sencilla sin tener que programar. Estos servicios permiten hacer algunos an\u00e1lisis sobre nuestros datos. Entre los principales est\u00e1n: https://carto.com/ https://www.mapbox.com/ https://mangomap.com/ https://www.giscloud.com/ https://www.instamaps.cat/","title":"Servicios"},{"location":"16_ejemplo_mobility/","text":"Ejemplo Mobility Creaci\u00f3n de un visor que permita el c\u00e1culo de Is\u00f3cronas Algunos de los servicios que ofrecen el c\u00e1lculo de Is\u00f3cronas son: Targomo , ISO4APP , Openrouteservice y Graphhopper Crear una carpeta con el nombre de visor-mobility . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que se carga un mapa centrado en Barcelona. Crear una API key. Al revisar la documentaci\u00f3n de la API del servicio de Openrouteservice 1 vemos que es necesario tener una API key para poder utilizarlo. Para crear la API key hay que darse de alta en la p\u00e1gina de Openrouteservice, es un servicio gratuito que tiene unas cuotas de uso. Crear una variable donde guardaremos nuestra API key. Escribir antes de la declaraci\u00f3n de nuestro mapa <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Cargar la respuesta del servicio utilizando el plugin de Leaflet llamado leaflet.reachability 2 . Este plugin permite hacer una llamada al servicio de Openrouteservice y cargar la respuesta en un mapa. Modificar el archivo index.html para cargar el plugin en nuestra aplicaci\u00f3n. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Agregar el control de Is\u00f3cronas al mapa utilizando el plugin. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparece un el bot\u00f3n del control de Is\u00f3cronas. Abrir la consola del desarrollador y ver las peticiones que se hacen al servicio de Openrouteservice. Modificar la aplicaci\u00f3n para que se haga el c\u00e1lculo de la Is\u00f3crona cuando el usuario haga click en un punto del mapa sin utilizar el plugin. Para ello primero hay que detectar el evento click en el mapa. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y abrir la consola del desarrollador. Hacer click sobre el mapa y ver que en la consola aparece el objeto del evento click. Inspeccionar este objeto y ver que tiene una propiedad llamada latlng que contine las coordenadas donde se ha hecho el click. Crear una funci\u00f3n que tenga como par\u00e1metro una posici\u00f3n (coordenada lat lon) y genere una url de llamada al servicio de is\u00f3cronas de Openrouteservice para que haga el c\u00e1lculo en la coordenada indicada. Copiar lo siguiente al final de nuestro c\u00f3digo <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Llamar a la funci\u00f3n crearUrlIsochrona cuando se hace click en el mapa. Escribir al final de la funci\u00f3n del click <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Recargar la p\u00e1gina y hacer click sobre el mapa para ver que en la consola aparece una url. Abrir esta url en el navegador para comprobar que responde con un GeoJSON que contiene la is\u00f3crona. Cargar la respuesta GeoJSON del servicio utilizando el plugin de Leaflet llamado leaflet-ajax 3 . Este plugin permite hacer una llamada AJAX a un servicio que retorne un JSON y cargar la respuesta en un mapa. Agregar lo siguiente justo despu\u00e9s de donde cargarmos el leaflet. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > - Agregar la capa geojsonLayer para que se inicialice vac\u00eda sin ning\u00fan elemento. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Utilizar el m\u00e9todo refresh para actualizar la capa geojsonLayer con la url generada al hacer click. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Refrescar el mapa y hacer click sobre el mapa para comprobar que se dibuja una nueva l\u00ednea is\u00f3crona. Pintar la l\u00ednea del color que indicamos. Por defecto se pinta la l\u00ednea de color azul. Esto es debido a que el Leaflet no sabe de que color pintar la l\u00ednea y utiliza el color por defecto. En la respuesta del servicio podemos ver que los elementos que nos retorna tienen unas propiedades (properties) en donde se listan una serie de atributos, uno de ellos es el value que corresponde con el valor del intervalo de tiempo. Lo que debemos hacer es decirle al leaflet que utilice esa propiedad para dar el color a la l\u00ednea. Escribir lo siguiente en nuestra capa geojsonLayer. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Recargar el mapa y hacer click para confirmar que los pol\u00edgonos se pintan de diferentes colores. Agregar un buscador de direcciones y puntos de inter\u00e9s al mapa Para agregar un buscador utilizaremos el plugin de Leaflet Leaflet.OpenCage.Search 4 desarrollado por OpenCage que permite de una forma f\u00e1cil y r\u00e1pida hacer llamadas al servicio de b\u00fasqueda de OpenCage Geocoder. Para ello hay que obtener un API_KEY en la p\u00e1gina de OpenCage 5 Cargar la librer\u00eda en nuestra aplicaci\u00f3n. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Crear la variable para la API key <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Agregar el control al mapa. Para utilizar el servicio de b\u00fasqueda tambi\u00e9n es necesario pasar nuestra API key: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var options_g = { key : API_KEY_OCG , limit : 10 }; var geocoder = L . Control . openCageSearch ( options_g ). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Recargar el mapa y comprobar que aparece el control. Calcular las is\u00f3cronas al seleccionar un resultado de la b\u00fasqueda. Modificar la funci\u00f3n _geocodeResultSelected del control geocoder <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var options_g = { key : API_KEY_OCG , limit : 10 }; var geocoder = L . Control . openCageSearch ( options_g ). addTo ( map ); geocoder . _geocodeResultSelected = function ( result ){ if ( this . options . collapsed ) { this . _collapse (); } console . log ( result ); }; var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Refrescar el mapa y abrir la consola de desarrolladores para comprobar que al seleccionar un resultado de la b\u00fasqueda aparece un objeto en la consola. Inspeccionar este objeto para ver que tiene una propiedad latlng que es lo que necesitamos para calcular las is\u00f3cronas. Llamar a nuestra funci\u00f3n crearUrlIsochrona en la funci\u00f3n del evento select para generar la url, luego refrescar la capa de geojsonLayer . Esto ya lo hemos hecho cuando el usuario hace click en el mapa. Copiar lo siguiente en la funci\u00f3n <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var options_g = { key : API_KEY_OCG , limit : 10 }; var geocoder = L . Control . openCageSearch ( options_g ). addTo ( map ); geocoder . _geocodeResultSelected = function ( result ){ if ( this . options . collapsed ) { this . _collapse (); } console . log ( result ); var url = crearUrlIsochrona ( result . center ); geojsonLayer . refresh ( url ); }; var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Refrescar la p\u00e1gina y al seleccionar un resultado de b\u00fasqueda comprobar que calcula las is\u00f3cronas desde ese punto. ejemplo is\u00f3cronas Ejercicio En la funci\u00f3n de crearUrlIsochrona cambiar el modo de transporte profile y el alcance range En el siguiente enlace se pueden ver las diferentes opciones de la API https://openrouteservice.org/dev/#/api-docs/isochrones/get Referencias https://openrouteservice.org \u21a9 https://github.com/traffordDataLab/leaflet.reachability \u21a9 https://github.com/calvinmetcalf/leaflet-ajax \u21a9 https://github.com/OpenCageData/leaflet-opencage-search \u21a9 https://opencagedata.com/ \u21a9","title":"15. Ejemplo Mobility"},{"location":"16_ejemplo_mobility/#ejemplo-mobility","text":"","title":"Ejemplo Mobility"},{"location":"16_ejemplo_mobility/#creacion-de-un-visor-que-permita-el-caculo-de-isocronas","text":"Algunos de los servicios que ofrecen el c\u00e1lculo de Is\u00f3cronas son: Targomo , ISO4APP , Openrouteservice y Graphhopper Crear una carpeta con el nombre de visor-mobility . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que se carga un mapa centrado en Barcelona. Crear una API key. Al revisar la documentaci\u00f3n de la API del servicio de Openrouteservice 1 vemos que es necesario tener una API key para poder utilizarlo. Para crear la API key hay que darse de alta en la p\u00e1gina de Openrouteservice, es un servicio gratuito que tiene unas cuotas de uso. Crear una variable donde guardaremos nuestra API key. Escribir antes de la declaraci\u00f3n de nuestro mapa <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Cargar la respuesta del servicio utilizando el plugin de Leaflet llamado leaflet.reachability 2 . Este plugin permite hacer una llamada al servicio de Openrouteservice y cargar la respuesta en un mapa. Modificar el archivo index.html para cargar el plugin en nuestra aplicaci\u00f3n. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Agregar el control de Is\u00f3cronas al mapa utilizando el plugin. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparece un el bot\u00f3n del control de Is\u00f3cronas. Abrir la consola del desarrollador y ver las peticiones que se hacen al servicio de Openrouteservice. Modificar la aplicaci\u00f3n para que se haga el c\u00e1lculo de la Is\u00f3crona cuando el usuario haga click en un punto del mapa sin utilizar el plugin. Para ello primero hay que detectar el evento click en el mapa. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y abrir la consola del desarrollador. Hacer click sobre el mapa y ver que en la consola aparece el objeto del evento click. Inspeccionar este objeto y ver que tiene una propiedad llamada latlng que contine las coordenadas donde se ha hecho el click. Crear una funci\u00f3n que tenga como par\u00e1metro una posici\u00f3n (coordenada lat lon) y genere una url de llamada al servicio de is\u00f3cronas de Openrouteservice para que haga el c\u00e1lculo en la coordenada indicada. Copiar lo siguiente al final de nuestro c\u00f3digo <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Llamar a la funci\u00f3n crearUrlIsochrona cuando se hace click en el mapa. Escribir al final de la funci\u00f3n del click <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Recargar la p\u00e1gina y hacer click sobre el mapa para ver que en la consola aparece una url. Abrir esta url en el navegador para comprobar que responde con un GeoJSON que contiene la is\u00f3crona. Cargar la respuesta GeoJSON del servicio utilizando el plugin de Leaflet llamado leaflet-ajax 3 . Este plugin permite hacer una llamada AJAX a un servicio que retorne un JSON y cargar la respuesta en un mapa. Agregar lo siguiente justo despu\u00e9s de donde cargarmos el leaflet. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > - Agregar la capa geojsonLayer para que se inicialice vac\u00eda sin ning\u00fan elemento. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Utilizar el m\u00e9todo refresh para actualizar la capa geojsonLayer con la url generada al hacer click. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Refrescar el mapa y hacer click sobre el mapa para comprobar que se dibuja una nueva l\u00ednea is\u00f3crona. Pintar la l\u00ednea del color que indicamos. Por defecto se pinta la l\u00ednea de color azul. Esto es debido a que el Leaflet no sabe de que color pintar la l\u00ednea y utiliza el color por defecto. En la respuesta del servicio podemos ver que los elementos que nos retorna tienen unas propiedades (properties) en donde se listan una serie de atributos, uno de ellos es el value que corresponde con el valor del intervalo de tiempo. Lo que debemos hacer es decirle al leaflet que utilice esa propiedad para dar el color a la l\u00ednea. Escribir lo siguiente en nuestra capa geojsonLayer. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Recargar el mapa y hacer click para confirmar que los pol\u00edgonos se pintan de diferentes colores.","title":"Creaci\u00f3n de un visor que permita el c\u00e1culo de Is\u00f3cronas"},{"location":"16_ejemplo_mobility/#agregar-un-buscador-de-direcciones-y-puntos-de-interes-al-mapa","text":"Para agregar un buscador utilizaremos el plugin de Leaflet Leaflet.OpenCage.Search 4 desarrollado por OpenCage que permite de una forma f\u00e1cil y r\u00e1pida hacer llamadas al servicio de b\u00fasqueda de OpenCage Geocoder. Para ello hay que obtener un API_KEY en la p\u00e1gina de OpenCage 5 Cargar la librer\u00eda en nuestra aplicaci\u00f3n. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Crear la variable para la API key <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Agregar el control al mapa. Para utilizar el servicio de b\u00fasqueda tambi\u00e9n es necesario pasar nuestra API key: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var options_g = { key : API_KEY_OCG , limit : 10 }; var geocoder = L . Control . openCageSearch ( options_g ). addTo ( map ); var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Recargar el mapa y comprobar que aparece el control. Calcular las is\u00f3cronas al seleccionar un resultado de la b\u00fasqueda. Modificar la funci\u00f3n _geocodeResultSelected del control geocoder <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var options_g = { key : API_KEY_OCG , limit : 10 }; var geocoder = L . Control . openCageSearch ( options_g ). addTo ( map ); geocoder . _geocodeResultSelected = function ( result ){ if ( this . options . collapsed ) { this . _collapse (); } console . log ( result ); }; var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Refrescar el mapa y abrir la consola de desarrolladores para comprobar que al seleccionar un resultado de la b\u00fasqueda aparece un objeto en la consola. Inspeccionar este objeto para ver que tiene una propiedad latlng que es lo que necesitamos para calcular las is\u00f3cronas. Llamar a nuestra funci\u00f3n crearUrlIsochrona en la funci\u00f3n del evento select para generar la url, luego refrescar la capa de geojsonLayer . Esto ya lo hemos hecho cuando el usuario hace click en el mapa. Copiar lo siguiente en la funci\u00f3n <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo Is\u00f3cronas Mapzen </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.css\" /> < link rel = \"stylesheet\" href = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/css/L.Control.OpenCageSearch.dev.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"http://rawgit.com/opencagedata/leaflet-opencage-search/master/dist/js/L.Control.OpenCageSearch.dev.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/gh/trafforddatalab/leaflet.reachability@v2.0.0/leaflet.reachability.js\" ></ script > < script > var API_KEY_ORS = '{TU_API_KEY}' ; var API_KEY_OCG = '{TU_API_KEY_OPENCAGE}' ; var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); // Initialise the reachability plugin L . control . reachability ({ // add settings/options here apiKey : API_KEY_ORS }). addTo ( map ); var options_g = { key : API_KEY_OCG , limit : 10 }; var geocoder = L . Control . openCageSearch ( options_g ). addTo ( map ); geocoder . _geocodeResultSelected = function ( result ){ if ( this . options . collapsed ) { this . _collapse (); } console . log ( result ); var url = crearUrlIsochrona ( result . center ); geojsonLayer . refresh ( url ); }; var geojsonLayer = new L . GeoJSON . AJAX ( '' ,{ style : function ( geoJsonFeature ){ var color = \"#0000FF\" ; switch ( geoJsonFeature . properties . value ) { case 300 : color = \"#0000FF\" ; break ; case 600 : color = \"#00FF00\" ; break ; case 900 : color = \"#FF0000\" ; break ; case 1200 : color = \"#FF00FF\" ; break ; default : color = \"#0000FF\" ; break ; } return { color : color }; } }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); var url = crearUrlIsochrona ( e . latlng ); console . log ( url ); geojsonLayer . refresh ( url ); }); function crearUrlIsochrona ( latlng ){ var lat = latlng . lat ; var lng = latlng . lng ; var url = 'https://api.openrouteservice.org/isochrones?' ; var json = { locations : lng + \",\" + lat , range_type : \"time\" , range : 1200 , interval : 300 , profile : \"cycling-regular\" , location_type : \"start\" , api_key : API_KEY_ORS }; var params = Object . keys ( json ). map ( function ( k ) { return encodeURIComponent ( k ) + '=' + encodeURIComponent ( json [ k ]) }). join ( '&' ) url += params ; return url ; } </ script > </ body > </ html > Refrescar la p\u00e1gina y al seleccionar un resultado de b\u00fasqueda comprobar que calcula las is\u00f3cronas desde ese punto. ejemplo is\u00f3cronas Ejercicio En la funci\u00f3n de crearUrlIsochrona cambiar el modo de transporte profile y el alcance range En el siguiente enlace se pueden ver las diferentes opciones de la API https://openrouteservice.org/dev/#/api-docs/isochrones/get","title":"Agregar un buscador de direcciones y puntos de inter\u00e9s al mapa"},{"location":"16_ejemplo_mobility/#referencias","text":"https://openrouteservice.org \u21a9 https://github.com/traffordDataLab/leaflet.reachability \u21a9 https://github.com/calvinmetcalf/leaflet-ajax \u21a9 https://github.com/OpenCageData/leaflet-opencage-search \u21a9 https://opencagedata.com/ \u21a9","title":"Referencias"},{"location":"17_ejemplo_geoservicio_realtime/","text":"Ejemplo servicio realtime para compartir la ubicaci\u00f3n Simularemos un servicio que permita compartir la ubicaci\u00f3n de los usuarios y ver que usuarios est\u00e1n en linea. Para ello utilizaremos la librer\u00eda Socket.io 1 que permite la comunicaci\u00f3n en tiempo real en dos direcciones cliente-servidor (tipo pull) y servidor-cliente (tipo push). Esto lo hace gracias a un socket 2 . Para mostrar los datos en el mapa utilizaremos la libreria Leaflet 3 . Para obtener la ubicaci\u00f3n de los usuarios podemos usar el plugin leaflet-locatecontrol 4 , en nuestro caso vamos a simular la ubicaci\u00f3n del usuario haciendo click sobre el mapa en lugar de utilizar la ubicaci\u00f3n del usuario. Creaci\u00f3n del mapa Crear una carpeta con el nombre de user-realtime . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para comrobar que se carga un mapa centrado en Barcelona. Capturar el evento click en el mapa. Luego de la declaraci\u00f3n de nuestra capa escribir los siguiente: <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y abrir la consola del desarrollador, al hacer click sobre el mapa ver que en la consola aparece el objeto del evento click. Inspeccionar este objeto para ver que tiene una propiedad llamada latlng que contine las coordenadas donde se ha hecho el click. Creaci\u00f3n del servicio que comparte la ubicaci\u00f3n de los usuarios Utilizaremos Nodejs 5 para implementar nuestro servidor web y utilizaremos el m\u00f3dulo de socket.io para establecer la comunicaci\u00f3n entre el cliente y nuestro servidor. Instalar Node.js. Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 12.13.1 LTS) y lo instalaremos con las opciones por defecto. Una vez instalado el Node abrir la consola para verificar que se ha instalado correctamente. Escribir node -v Navegar hasta nuestra carpeta user-realtime y escribir: npm init Con este comando estaremos creando el archivo package.json . Este comando solicita varios elementos como, por ejemplo, el nombre y la versi\u00f3n de la aplicaci\u00f3n. Por ahora, s\u00f3lo hay que pulsar ENTER para aceptar los valores predeterminados. Instalar las dependencias para crear nuestro servicio de proxy. En este caso utilizaremos Express 6 como servidor web y el m\u00f3dulo socket.io 7 . Instalar el express y guardarlo en la lista de dependencias npm install express --save Instalar el socket.io y guardarlo en la lista de dependencias npm install socket.io --save Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que contendr\u00e1 nuestra aplicaci\u00f3n que servir\u00e1 de servidor web. Para ello copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var http = require ( 'http' ). Server ( app ); var io = require ( 'socket.io' )( http ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); io . on ( 'connection' , function ( socket ){ console . log ( 'a user connected' ); }); http . listen ( 3000 , function (){ console . log ( 'listening on *:3000' ); }); Probar que nuestro servidor est\u00e1 funcionando, escribiendo: node app.js Abrir la url de nuestro servidor http://localhost:3000/ en el navegador para ver nuestro mapa. Modificar el mapa Agregar la librer\u00eda cliente de socket.io. Escribir en el archivo index.html justo debajo de donde cargamos el leaflet <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Declarar la variable que va a tener el objeto socket.io al inicio de nuestro c\u00f3digo antes de la declaraci\u00f3n del mapa escribir los siguiente: <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Recargar la p\u00e1gina y ver que en la consola aparece el mensaje de a user connected . Enviar el evento click al servidor. En la funcion que se llama al hacer click sobre el mapa escribir los siguiente para enviar un evento al servidor. Este evento lo llamaremos user_click y le pasaremos como par\u00e1metro la posici\u00f3n del click. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); socket . emit ( 'user_click' , e . latlng ); }); </ script > </ body > </ html > Modificar el servidor Escuchar al evento user_click en nuestra aplicaci\u00f3n del servidor. Dentro de la funci\u00f3n que se llama en el io.on es donde se crea el socket de conexi\u00f3n, por lo tando escribir nuestro c\u00f3digo dentro de la misma. Debajo de donde escribimos el mensaje de a user connected escribir lo siguiente: var express = require ( 'express' ); var app = express (); var http = require ( 'http' ). Server ( app ); var io = require ( 'socket.io' )( http ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); io . on ( 'connection' , function ( socket ){ console . log ( 'a user connected' ); socket . on ( 'user_click' , function ( msg ){ console . log ( msg ); }); }); http . listen ( 3000 , function (){ console . log ( 'listening on *:3000' ); }); Reiniciar nuestro servidor de node en la consola presionar Crtl+c. Volver a escribir node app.js. Recargar la p\u00e1gina y hacer click sobre el mapa para ver que en la consola aparece las coordenadas del click. Con esto ya hemos logrado la comunicaci\u00f3n cliente-servidor. Lograr la comunicaci\u00f3n servidor-cliente y que el servidor notifique a todos los cliente para esto debemos emitir un evento en nuestro servidor. Este evento lo llamaremos new_user . Copiar lo siguiente para emitir el evento dentro de la funci\u00f3n que se llama en el evento user_click . var express = require ( 'express' ); var app = express (); var http = require ( 'http' ). Server ( app ); var io = require ( 'socket.io' )( http ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); io . on ( 'connection' , function ( socket ){ console . log ( 'a user connected' ); socket . on ( 'user_click' , function ( msg ){ console . log ( msg ); io . emit ( 'new_user' , msg ); }); }); http . listen ( 3000 , function (){ console . log ( 'listening on *:3000' ); }); Modificar el mapa Escuchar el evento new_user en nuestro cliente. Al final de nuestro c\u00f3digo html escribir <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); socket . emit ( 'user_click' , e . latlng ); }); socket . on ( 'new_user' , function ( msg ){ console . log ( msg ); }); </ script > </ body > </ html > Recargar el servidor y recargar la p\u00e1gina. Clicar sobre el mapa y ver las coordenadas del click tanto en el la consola del servidor como en la consola de desarrolladores del navegador. Mostrar un marcador en el mapa en la posici\u00f3n donde el usuario hace click. En nuestro html en la funci\u00f3n que escucha el evento new_user agregar el siguiente c\u00f3digo <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); socket . emit ( 'user_click' , e . latlng ); }); socket . on ( 'new_user' , function ( msg ){ console . log ( msg ); L . marker ([ msg . lat , msg . lng ]). addTo ( map ); }); </ script > </ body > </ html > Recargar nuestra aplicaci\u00f3n y abrir otra pesta\u00f1a con nuestra aplicaci\u00f3n para simular que somos dos usuarios distintos. Hacer click en el mapa en cualquiera de las pesta\u00f1as y ver que nos aparece el marcador en ambas pesta\u00f1as. Referencias https://socket.io/ \u21a9 https://es.wikipedia.org/wiki/Socket_de_Internet \u21a9 http://leafletjs.com/ \u21a9 https://github.com/domoritz/leaflet-locatecontrol \u21a9 https://nodejs.org/es/ \u21a9 http://expressjs.com/ \u21a9 https://github.com/socketio/socket.io \u21a9","title":"16. Ejemplo servicio realtime para compartir la ubicaci\u00f3n"},{"location":"17_ejemplo_geoservicio_realtime/#ejemplo-servicio-realtime-para-compartir-la-ubicacion","text":"Simularemos un servicio que permita compartir la ubicaci\u00f3n de los usuarios y ver que usuarios est\u00e1n en linea. Para ello utilizaremos la librer\u00eda Socket.io 1 que permite la comunicaci\u00f3n en tiempo real en dos direcciones cliente-servidor (tipo pull) y servidor-cliente (tipo push). Esto lo hace gracias a un socket 2 . Para mostrar los datos en el mapa utilizaremos la libreria Leaflet 3 . Para obtener la ubicaci\u00f3n de los usuarios podemos usar el plugin leaflet-locatecontrol 4 , en nuestro caso vamos a simular la ubicaci\u00f3n del usuario haciendo click sobre el mapa en lugar de utilizar la ubicaci\u00f3n del usuario.","title":"Ejemplo servicio realtime para compartir la ubicaci\u00f3n"},{"location":"17_ejemplo_geoservicio_realtime/#creacion-del-mapa","text":"Crear una carpeta con el nombre de user-realtime . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para comrobar que se carga un mapa centrado en Barcelona. Capturar el evento click en el mapa. Luego de la declaraci\u00f3n de nuestra capa escribir los siguiente: <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y abrir la consola del desarrollador, al hacer click sobre el mapa ver que en la consola aparece el objeto del evento click. Inspeccionar este objeto para ver que tiene una propiedad llamada latlng que contine las coordenadas donde se ha hecho el click.","title":"Creaci\u00f3n del mapa"},{"location":"17_ejemplo_geoservicio_realtime/#creacion-del-servicio-que-comparte-la-ubicacion-de-los-usuarios","text":"Utilizaremos Nodejs 5 para implementar nuestro servidor web y utilizaremos el m\u00f3dulo de socket.io para establecer la comunicaci\u00f3n entre el cliente y nuestro servidor. Instalar Node.js. Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 12.13.1 LTS) y lo instalaremos con las opciones por defecto. Una vez instalado el Node abrir la consola para verificar que se ha instalado correctamente. Escribir node -v Navegar hasta nuestra carpeta user-realtime y escribir: npm init Con este comando estaremos creando el archivo package.json . Este comando solicita varios elementos como, por ejemplo, el nombre y la versi\u00f3n de la aplicaci\u00f3n. Por ahora, s\u00f3lo hay que pulsar ENTER para aceptar los valores predeterminados. Instalar las dependencias para crear nuestro servicio de proxy. En este caso utilizaremos Express 6 como servidor web y el m\u00f3dulo socket.io 7 . Instalar el express y guardarlo en la lista de dependencias npm install express --save Instalar el socket.io y guardarlo en la lista de dependencias npm install socket.io --save Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que contendr\u00e1 nuestra aplicaci\u00f3n que servir\u00e1 de servidor web. Para ello copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var http = require ( 'http' ). Server ( app ); var io = require ( 'socket.io' )( http ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); io . on ( 'connection' , function ( socket ){ console . log ( 'a user connected' ); }); http . listen ( 3000 , function (){ console . log ( 'listening on *:3000' ); }); Probar que nuestro servidor est\u00e1 funcionando, escribiendo: node app.js Abrir la url de nuestro servidor http://localhost:3000/ en el navegador para ver nuestro mapa.","title":"Creaci\u00f3n del servicio que comparte la ubicaci\u00f3n de los usuarios"},{"location":"17_ejemplo_geoservicio_realtime/#modificar-el-mapa","text":"Agregar la librer\u00eda cliente de socket.io. Escribir en el archivo index.html justo debajo de donde cargamos el leaflet <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Declarar la variable que va a tener el objeto socket.io al inicio de nuestro c\u00f3digo antes de la declaraci\u00f3n del mapa escribir los siguiente: <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); }); </ script > </ body > </ html > Recargar la p\u00e1gina y ver que en la consola aparece el mensaje de a user connected . Enviar el evento click al servidor. En la funcion que se llama al hacer click sobre el mapa escribir los siguiente para enviar un evento al servidor. Este evento lo llamaremos user_click y le pasaremos como par\u00e1metro la posici\u00f3n del click. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); socket . emit ( 'user_click' , e . latlng ); }); </ script > </ body > </ html >","title":"Modificar el mapa"},{"location":"17_ejemplo_geoservicio_realtime/#modificar-el-servidor","text":"Escuchar al evento user_click en nuestra aplicaci\u00f3n del servidor. Dentro de la funci\u00f3n que se llama en el io.on es donde se crea el socket de conexi\u00f3n, por lo tando escribir nuestro c\u00f3digo dentro de la misma. Debajo de donde escribimos el mensaje de a user connected escribir lo siguiente: var express = require ( 'express' ); var app = express (); var http = require ( 'http' ). Server ( app ); var io = require ( 'socket.io' )( http ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); io . on ( 'connection' , function ( socket ){ console . log ( 'a user connected' ); socket . on ( 'user_click' , function ( msg ){ console . log ( msg ); }); }); http . listen ( 3000 , function (){ console . log ( 'listening on *:3000' ); }); Reiniciar nuestro servidor de node en la consola presionar Crtl+c. Volver a escribir node app.js. Recargar la p\u00e1gina y hacer click sobre el mapa para ver que en la consola aparece las coordenadas del click. Con esto ya hemos logrado la comunicaci\u00f3n cliente-servidor. Lograr la comunicaci\u00f3n servidor-cliente y que el servidor notifique a todos los cliente para esto debemos emitir un evento en nuestro servidor. Este evento lo llamaremos new_user . Copiar lo siguiente para emitir el evento dentro de la funci\u00f3n que se llama en el evento user_click . var express = require ( 'express' ); var app = express (); var http = require ( 'http' ). Server ( app ); var io = require ( 'socket.io' )( http ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); io . on ( 'connection' , function ( socket ){ console . log ( 'a user connected' ); socket . on ( 'user_click' , function ( msg ){ console . log ( msg ); io . emit ( 'new_user' , msg ); }); }); http . listen ( 3000 , function (){ console . log ( 'listening on *:3000' ); });","title":"Modificar el servidor"},{"location":"17_ejemplo_geoservicio_realtime/#modificar-el-mapa_1","text":"Escuchar el evento new_user en nuestro cliente. Al final de nuestro c\u00f3digo html escribir <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); socket . emit ( 'user_click' , e . latlng ); }); socket . on ( 'new_user' , function ( msg ){ console . log ( msg ); }); </ script > </ body > </ html > Recargar el servidor y recargar la p\u00e1gina. Clicar sobre el mapa y ver las coordenadas del click tanto en el la consola del servidor como en la consola de desarrolladores del navegador. Mostrar un marcador en el mapa en la posici\u00f3n donde el usuario hace click. En nuestro html en la funci\u00f3n que escucha el evento new_user agregar el siguiente c\u00f3digo <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js\" ></ script > < script type = \"text/javascript\" > var socket = io (); var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); map . on ( 'click' , function ( e ){ console . log ( e ); socket . emit ( 'user_click' , e . latlng ); }); socket . on ( 'new_user' , function ( msg ){ console . log ( msg ); L . marker ([ msg . lat , msg . lng ]). addTo ( map ); }); </ script > </ body > </ html > Recargar nuestra aplicaci\u00f3n y abrir otra pesta\u00f1a con nuestra aplicaci\u00f3n para simular que somos dos usuarios distintos. Hacer click en el mapa en cualquiera de las pesta\u00f1as y ver que nos aparece el marcador en ambas pesta\u00f1as.","title":"Modificar el mapa"},{"location":"17_ejemplo_geoservicio_realtime/#referencias","text":"https://socket.io/ \u21a9 https://es.wikipedia.org/wiki/Socket_de_Internet \u21a9 http://leafletjs.com/ \u21a9 https://github.com/domoritz/leaflet-locatecontrol \u21a9 https://nodejs.org/es/ \u21a9 http://expressjs.com/ \u21a9 https://github.com/socketio/socket.io \u21a9","title":"Referencias"},{"location":"18_ejemplo_gtfs/","text":"Ejemplo GTFS \u00bfQu\u00e9 es la GTFS? La Especificaci\u00f3n general de feeds de transporte p\u00fablico (GTFS) define un formato com\u00fan para los horarios de transporte p\u00fablico y la informaci\u00f3n geogr\u00e1fica asociada a ellos. Los \"feeds\" GTFS permiten que las empresas de transporte p\u00fablico publiquen sus datos de transporte y que los programadores escriban aplicaciones que consuman esos datos de manera interoperable 1 . Creaci\u00f3n de un visor que muestre las l\u00ednes y paradas de un GTFS Para crear un visor de mapas utilizaremos la librer\u00eda de mapas Leaflet 2 . Y cargaremos los datos de portal de la Plataforma VLCi (Valencia SmartCity) 3 Crear una carpeta con el nombre de visor-gtfs . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que se carga un mapa centrado en Valencia. Crear el proxy Crear un archivo con el nombre de package.json dentro de la carpeta. Abrir el archivo package.json con un editor de texto y copiar el siguiente c\u00f3digo. { \"name\" : \"visor-gtfs\" , \"version\" : \"1.0.0\" , \"description\" : \"\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\" : \"\" , \"license\" : \"ISC\" , \"dependencies\" : { \"assert\" : \"^2.0.0\" , \"express\" : \"^4.17.1\" , \"fast-csv\" : \"^3.4.0\" , \"request\" : \"^2.88.0\" , \"yauzl\" : \"^2.10.0\" } } Instalar Node.js 4 . Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 10.13.0 LTS) y lo instalaremos con las opciones por defecto. Abrir la consola para verificar que se ha instalado correctamente y escribir node -v Navegar hasta nuestra carpeta visor-gtfs y escribir: npm install Con este comando estamos instalando las dependencias declarades en el archivo package.json Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que servir\u00e1 de proxy con el servicio GTFS. Copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); Probar que nuestro proxy est\u00e1 funcionando, escribir: node app.js Escribir en el navegador http://localhost:3000 y ver nuestro mapa. Crear un archivo llamado gtfs2geojson.js . Copiar en el archivo el c\u00f3digo del siguiente enlace https://raw.githubusercontent.com/andrewharvey/gtfs2geojson/master/index.js este c\u00f3digo convierte datos de un GTFS en un GeoJSON. C\u00f3digo basado en la librer\u00eda https://github.com/andrewharvey/gtfs2geojson Cargar en archivo en nuestra app.js. Escribir lo siguiente justo desp\u00faes de donde se carga el m\u00f3dulo yauzl var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); Crear la variable que contiene la url del servicio GTFS de L\u00edneas, paradas, horarios de autobuses de la EMT de Valencia 5 . Escribir lo siguiente justo despues de la variable gtfs2geojson var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); Crear una funci\u00f3n llamada getZip para descargar un archivo. La funci\u00f3n recibe como par\u00e1metro una url. Escribir lo siguiente al final del archivo app.js var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } Crear una funci\u00f3n que extrae un archivo de un zip. La funcion recibe como par\u00e1metro el nombre del archivo que se desea extraer. Escribir lo siguiente al final del archivo app.js var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } function leerZip ( archivo ){ return new Promise ( function ( resolve , reject ) { yauzl . open ( 'gtfs.zip' , { lazyEntries : true }, function ( err , zipfile ) { if ( err ) throw err ; zipfile . readEntry (); zipfile . on ( \"entry\" , function ( entry ) { if ( /\\/$/ . test ( entry . fileName )) { // Directory file names end with '/'. // Note that entires for directories themselves are optional. // An entry's fileName implicitly requires its parent directories to exist. zipfile . readEntry (); } else { // file entry if ( entry . fileName === archivo ){ zipfile . openReadStream ( entry , function ( err , readStream ) { if ( err ) throw err ; var file = fs . createWriteStream ( entry . fileName ); readStream . pipe ( file ); file . on ( 'finish' , function (){ resolve (); }); }); } else { zipfile . readEntry (); } } }); }); }); } Descargar el archivo GTFS y guardarlo en el ordenador. Escribir lo siguiente justo antes de la l\u00ednea donde definimos el puerto por el cual escucha nuestro servidor var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/getdata/*\" , function ( req , res ) { getZip ( url ). then ( function (){ Promise . all ([ leerZip ( 'shapes.txt' ), leerZip ( 'stops.txt' )]). then ( values => { res . json ({ \"msg\" : \"archivos descargados\" }); }); }); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } function leerZip ( archivo ){ return new Promise ( function ( resolve , reject ) { yauzl . open ( 'gtfs.zip' , { lazyEntries : true }, function ( err , zipfile ) { if ( err ) throw err ; zipfile . readEntry (); zipfile . on ( \"entry\" , function ( entry ) { if ( /\\/$/ . test ( entry . fileName )) { // Directory file names end with '/'. // Note that entires for directories themselves are optional. // An entry's fileName implicitly requires its parent directories to exist. zipfile . readEntry (); } else { // file entry if ( entry . fileName === archivo ){ zipfile . openReadStream ( entry , function ( err , readStream ) { if ( err ) throw err ; var file = fs . createWriteStream ( entry . fileName ); readStream . pipe ( file ); file . on ( 'finish' , function (){ resolve (); }); }); } else { zipfile . readEntry (); } } }); }); }); } Reiniciar nuestro servidor de node, ir a la consola y presionar Crtl+c. Escribir node app.js. Abrir la url http://localhost:3000/getdata/ en el navegador para comprobar que se han descargado correctamente los archivos gtfs.zip , shapes.txt y stops.txt . Leer los archivos GTFS y convertirlos a GeoJson. Escribir lo siguiente justo antes de la l\u00ednea donde definimos el puerto por el cual escucha nuestro servidor var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/getdata/*\" , function ( req , res ) { getZip ( url ). then ( function (){ Promise . all ([ leerZip ( 'shapes.txt' ), leerZip ( 'stops.txt' )]). then ( values => { res . json ({ \"msg\" : \"archivos descargados\" }); }); }); }); app . all ( \"/stops/*\" , function ( req , res ) { gtfs2geojson . stops ( fs . readFileSync ( 'stops.txt' , 'utf8' ), function ( result ){ res . json ( result ); }); }); app . all ( \"/shapes/*\" , function ( req , res ) { gtfs2geojson . lines ( fs . readFileSync ( 'shapes.txt' , 'utf8' ), function ( result ){ res . json ( result ); }); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } function leerZip ( archivo ){ return new Promise ( function ( resolve , reject ) { yauzl . open ( 'gtfs.zip' , { lazyEntries : true }, function ( err , zipfile ) { if ( err ) throw err ; zipfile . readEntry (); zipfile . on ( \"entry\" , function ( entry ) { if ( /\\/$/ . test ( entry . fileName )) { // Directory file names end with '/'. // Note that entires for directories themselves are optional. // An entry's fileName implicitly requires its parent directories to exist. zipfile . readEntry (); } else { // file entry if ( entry . fileName === archivo ){ zipfile . openReadStream ( entry , function ( err , readStream ) { if ( err ) throw err ; var file = fs . createWriteStream ( entry . fileName ); readStream . pipe ( file ); file . on ( 'finish' , function (){ resolve (); }); }); } else { zipfile . readEntry (); } } }); }); }); } Reiniciar nuestro servidor de node, ir a la consola y presionar Crtl+c. Escribir node app.js. Abrir la url http://localhost:3000/stops/ en el navegador para comprobar que se muestra un GeoJson con la informaci\u00f3n de las paradas. Modificar el mapa Cargar este JSON en nuestro mapa utilizando un plugin de Leaflet llamado leaflet-ajax 6 . Este plugin permite hacer una llamada AJAX a un servicio que retorne un JSON y cargar la respuesta en un mapa. Para cargar este plugin debemos agregar lo siguiente justo despu\u00e9s de donde hemos cargado el leaflet <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Utilizar el plugin para agregar la capa de paradas al mapa llamando a nuestro servidor. Agregar lo siguiente al final de nuestro c\u00f3digo: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparecen los puntos de las paradas en el mapa. Utilizar el plugin para agregar la capa de l\u00edneas al mapa llamando a nuestro servidor. Agregar lo siguiente al final de nuestro c\u00f3digo: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); var geojsonLineas = new L . GeoJSON . AJAX ( '/shapes/' ,{ }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparecen las l\u00edneas del bus en el mapa. Cargar la librer\u00eda de manipulaci\u00f3n de colores chroma.js 7 . Escribir lo siguiente despu\u00e9s de donde cargarmos el plugin de leaflet.ajax <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.6/chroma.min.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); var geojsonLineas = new L . GeoJSON . AJAX ( '/shapes/' ,{ }). addTo ( map ); </ script > </ body > </ html > Dar estilo a la capa de l\u00edneas generando un color aleatorio. Escribir lo siguiente en las opciones de la capa geojsonLineas <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.6/chroma.min.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); var geojsonLineas = new L . GeoJSON . AJAX ( '/shapes/' ,{ style : function ( geoJsonFeature ){ return { color : chroma . random (), opacity : 0.5 }; } }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparecen las l\u00edneas del bus en el mapa con colores aleatorios. ejemplo gtfs Ejercicios Mostrar un popup con informaci\u00f3n de la propiedad shape_id al hacer click en la capa de l\u00edneas Cargar datos del gtfs de FGC https://www.fgc.cat/es/opendata/ En el siguiente enlace est\u00e1 el fichero de gtfs https://www.fgc.cat/wp-content/uploads/2018/02/google_transit.zip Centrar el mapa en Barcelona Referencias https://developers.google.com/transit/gtfs/?hl=es-419 \u21a9 http://leafletjs.com/ \u21a9 https://opendata.vlci.valencia.es \u21a9 https://nodejs.org/es/ \u21a9 http://gobiernoabierto.valencia.es/es/dataset/?id=google-transit-lineas-paradas-horarios-de-autobuses \u21a9 https://github.com/calvinmetcalf/leaflet-ajax \u21a9 https://github.com/gka/chroma.js/ \u21a9","title":"17. Ejemplo GTFS"},{"location":"18_ejemplo_gtfs/#ejemplo-gtfs","text":"","title":"Ejemplo GTFS"},{"location":"18_ejemplo_gtfs/#que-es-la-gtfs","text":"La Especificaci\u00f3n general de feeds de transporte p\u00fablico (GTFS) define un formato com\u00fan para los horarios de transporte p\u00fablico y la informaci\u00f3n geogr\u00e1fica asociada a ellos. Los \"feeds\" GTFS permiten que las empresas de transporte p\u00fablico publiquen sus datos de transporte y que los programadores escriban aplicaciones que consuman esos datos de manera interoperable 1 .","title":"\u00bfQu\u00e9 es la GTFS?"},{"location":"18_ejemplo_gtfs/#creacion-de-un-visor-que-muestre-las-lines-y-paradas-de-un-gtfs","text":"Para crear un visor de mapas utilizaremos la librer\u00eda de mapas Leaflet 2 . Y cargaremos los datos de portal de la Plataforma VLCi (Valencia SmartCity) 3 Crear una carpeta con el nombre de visor-gtfs . Crear un archivo con el nombre de index.html dentro de la carpeta. Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para confirmar que se carga un mapa centrado en Valencia.","title":"Creaci\u00f3n de un visor que muestre las l\u00ednes y paradas de un GTFS"},{"location":"18_ejemplo_gtfs/#crear-el-proxy","text":"Crear un archivo con el nombre de package.json dentro de la carpeta. Abrir el archivo package.json con un editor de texto y copiar el siguiente c\u00f3digo. { \"name\" : \"visor-gtfs\" , \"version\" : \"1.0.0\" , \"description\" : \"\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\" : \"\" , \"license\" : \"ISC\" , \"dependencies\" : { \"assert\" : \"^2.0.0\" , \"express\" : \"^4.17.1\" , \"fast-csv\" : \"^3.4.0\" , \"request\" : \"^2.88.0\" , \"yauzl\" : \"^2.10.0\" } } Instalar Node.js 4 . Descargar la \u00faltima versi\u00f3n LTS (en este momento es la 10.13.0 LTS) y lo instalaremos con las opciones por defecto. Abrir la consola para verificar que se ha instalado correctamente y escribir node -v Navegar hasta nuestra carpeta visor-gtfs y escribir: npm install Con este comando estamos instalando las dependencias declarades en el archivo package.json Al ejecutar estos comandos veremos que se crea una carpeta llamada node_modules donde se guardan los m\u00f3dulos instalados. Crear un archivo llamado app.js que servir\u00e1 de proxy con el servicio GTFS. Copiar lo siguiente en este archivo. var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); Probar que nuestro proxy est\u00e1 funcionando, escribir: node app.js Escribir en el navegador http://localhost:3000 y ver nuestro mapa. Crear un archivo llamado gtfs2geojson.js . Copiar en el archivo el c\u00f3digo del siguiente enlace https://raw.githubusercontent.com/andrewharvey/gtfs2geojson/master/index.js este c\u00f3digo convierte datos de un GTFS en un GeoJSON. C\u00f3digo basado en la librer\u00eda https://github.com/andrewharvey/gtfs2geojson Cargar en archivo en nuestra app.js. Escribir lo siguiente justo desp\u00faes de donde se carga el m\u00f3dulo yauzl var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); Crear la variable que contiene la url del servicio GTFS de L\u00edneas, paradas, horarios de autobuses de la EMT de Valencia 5 . Escribir lo siguiente justo despues de la variable gtfs2geojson var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); Crear una funci\u00f3n llamada getZip para descargar un archivo. La funci\u00f3n recibe como par\u00e1metro una url. Escribir lo siguiente al final del archivo app.js var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } Crear una funci\u00f3n que extrae un archivo de un zip. La funcion recibe como par\u00e1metro el nombre del archivo que se desea extraer. Escribir lo siguiente al final del archivo app.js var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } function leerZip ( archivo ){ return new Promise ( function ( resolve , reject ) { yauzl . open ( 'gtfs.zip' , { lazyEntries : true }, function ( err , zipfile ) { if ( err ) throw err ; zipfile . readEntry (); zipfile . on ( \"entry\" , function ( entry ) { if ( /\\/$/ . test ( entry . fileName )) { // Directory file names end with '/'. // Note that entires for directories themselves are optional. // An entry's fileName implicitly requires its parent directories to exist. zipfile . readEntry (); } else { // file entry if ( entry . fileName === archivo ){ zipfile . openReadStream ( entry , function ( err , readStream ) { if ( err ) throw err ; var file = fs . createWriteStream ( entry . fileName ); readStream . pipe ( file ); file . on ( 'finish' , function (){ resolve (); }); }); } else { zipfile . readEntry (); } } }); }); }); } Descargar el archivo GTFS y guardarlo en el ordenador. Escribir lo siguiente justo antes de la l\u00ednea donde definimos el puerto por el cual escucha nuestro servidor var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/getdata/*\" , function ( req , res ) { getZip ( url ). then ( function (){ Promise . all ([ leerZip ( 'shapes.txt' ), leerZip ( 'stops.txt' )]). then ( values => { res . json ({ \"msg\" : \"archivos descargados\" }); }); }); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } function leerZip ( archivo ){ return new Promise ( function ( resolve , reject ) { yauzl . open ( 'gtfs.zip' , { lazyEntries : true }, function ( err , zipfile ) { if ( err ) throw err ; zipfile . readEntry (); zipfile . on ( \"entry\" , function ( entry ) { if ( /\\/$/ . test ( entry . fileName )) { // Directory file names end with '/'. // Note that entires for directories themselves are optional. // An entry's fileName implicitly requires its parent directories to exist. zipfile . readEntry (); } else { // file entry if ( entry . fileName === archivo ){ zipfile . openReadStream ( entry , function ( err , readStream ) { if ( err ) throw err ; var file = fs . createWriteStream ( entry . fileName ); readStream . pipe ( file ); file . on ( 'finish' , function (){ resolve (); }); }); } else { zipfile . readEntry (); } } }); }); }); } Reiniciar nuestro servidor de node, ir a la consola y presionar Crtl+c. Escribir node app.js. Abrir la url http://localhost:3000/getdata/ en el navegador para comprobar que se han descargado correctamente los archivos gtfs.zip , shapes.txt y stops.txt . Leer los archivos GTFS y convertirlos a GeoJson. Escribir lo siguiente justo antes de la l\u00ednea donde definimos el puerto por el cual escucha nuestro servidor var express = require ( 'express' ); var app = express (); var request = require ( 'request' ); var path = require ( 'path' ); var https = require ( 'https' ); var fs = require ( 'fs' ); var yauzl = require ( \"yauzl\" ); var gtfs2geojson = require ( './gtfs2geojson.js' ); const url = 'https://opendata.vlci.valencia.es:8443/dataset/4645f8bf-28d7-4420-bab2-d5c5e7de2a5a/resource/11591648-a984-4d64-89e3-3730f3123403/download/googletransit.zip' ; app . get ( '/' , function ( req , res ){ res . sendFile ( __dirname + '/index.html' ); }); app . all ( \"/getdata/*\" , function ( req , res ) { getZip ( url ). then ( function (){ Promise . all ([ leerZip ( 'shapes.txt' ), leerZip ( 'stops.txt' )]). then ( values => { res . json ({ \"msg\" : \"archivos descargados\" }); }); }); }); app . all ( \"/stops/*\" , function ( req , res ) { gtfs2geojson . stops ( fs . readFileSync ( 'stops.txt' , 'utf8' ), function ( result ){ res . json ( result ); }); }); app . all ( \"/shapes/*\" , function ( req , res ) { gtfs2geojson . lines ( fs . readFileSync ( 'shapes.txt' , 'utf8' ), function ( result ){ res . json ( result ); }); }); app . listen ( 3000 ); function getZip ( url ){ return new Promise ( function ( resolve , reject ) { var file = fs . createWriteStream ( \"gtfs.zip\" ); var request = https . get ( url , function ( response ) { response . pipe ( file ); }); file . on ( 'finish' , function (){ resolve (); }); }); } function leerZip ( archivo ){ return new Promise ( function ( resolve , reject ) { yauzl . open ( 'gtfs.zip' , { lazyEntries : true }, function ( err , zipfile ) { if ( err ) throw err ; zipfile . readEntry (); zipfile . on ( \"entry\" , function ( entry ) { if ( /\\/$/ . test ( entry . fileName )) { // Directory file names end with '/'. // Note that entires for directories themselves are optional. // An entry's fileName implicitly requires its parent directories to exist. zipfile . readEntry (); } else { // file entry if ( entry . fileName === archivo ){ zipfile . openReadStream ( entry , function ( err , readStream ) { if ( err ) throw err ; var file = fs . createWriteStream ( entry . fileName ); readStream . pipe ( file ); file . on ( 'finish' , function (){ resolve (); }); }); } else { zipfile . readEntry (); } } }); }); }); } Reiniciar nuestro servidor de node, ir a la consola y presionar Crtl+c. Escribir node app.js. Abrir la url http://localhost:3000/stops/ en el navegador para comprobar que se muestra un GeoJson con la informaci\u00f3n de las paradas.","title":"Crear el proxy"},{"location":"18_ejemplo_gtfs/#modificar-el-mapa","text":"Cargar este JSON en nuestro mapa utilizando un plugin de Leaflet llamado leaflet-ajax 6 . Este plugin permite hacer una llamada AJAX a un servicio que retorne un JSON y cargar la respuesta en un mapa. Para cargar este plugin debemos agregar lo siguiente justo despu\u00e9s de donde hemos cargado el leaflet <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Utilizar el plugin para agregar la capa de paradas al mapa llamando a nuestro servidor. Agregar lo siguiente al final de nuestro c\u00f3digo: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparecen los puntos de las paradas en el mapa. Utilizar el plugin para agregar la capa de l\u00edneas al mapa llamando a nuestro servidor. Agregar lo siguiente al final de nuestro c\u00f3digo: <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); var geojsonLineas = new L . GeoJSON . AJAX ( '/shapes/' ,{ }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparecen las l\u00edneas del bus en el mapa. Cargar la librer\u00eda de manipulaci\u00f3n de colores chroma.js 7 . Escribir lo siguiente despu\u00e9s de donde cargarmos el plugin de leaflet.ajax <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.6/chroma.min.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); var geojsonLineas = new L . GeoJSON . AJAX ( '/shapes/' ,{ }). addTo ( map ); </ script > </ body > </ html > Dar estilo a la capa de l\u00edneas generando un color aleatorio. Escribir lo siguiente en las opciones de la capa geojsonLineas <!DOCTYPE html> < html > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Ejemplo GTFS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { height : 100 % ; width : 100 % ; position : absolute ; } </ style > </ head > < body > < div id = \"map\" > </ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://calvinmetcalf.github.io/leaflet-ajax/dist/leaflet.ajax.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.6/chroma.min.js\" ></ script > < script > var map = L . map ( 'map' ); map . setView ([ 39.4652 , - 0.3861 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojsonParadas = new L . GeoJSON . AJAX ( '/stops/' ,{ pointToLayer : function ( feature , latlng ) { return new L . CircleMarker ( latlng , { radius : 5 , fillColor : \"#A30000\" , color : \"#A30000\" , weight : 1 , opacity : 1 , fillOpacity : 0.8 }); }, onEachFeature : function ( feature , layer ) { layer . bindPopup ( feature . properties . stop_name ); } }). addTo ( map ); var geojsonLineas = new L . GeoJSON . AJAX ( '/shapes/' ,{ style : function ( geoJsonFeature ){ return { color : chroma . random (), opacity : 0.5 }; } }). addTo ( map ); </ script > </ body > </ html > Recargar el mapa y comprobar que aparecen las l\u00edneas del bus en el mapa con colores aleatorios. ejemplo gtfs Ejercicios Mostrar un popup con informaci\u00f3n de la propiedad shape_id al hacer click en la capa de l\u00edneas Cargar datos del gtfs de FGC https://www.fgc.cat/es/opendata/ En el siguiente enlace est\u00e1 el fichero de gtfs https://www.fgc.cat/wp-content/uploads/2018/02/google_transit.zip Centrar el mapa en Barcelona","title":"Modificar el mapa"},{"location":"18_ejemplo_gtfs/#referencias","text":"https://developers.google.com/transit/gtfs/?hl=es-419 \u21a9 http://leafletjs.com/ \u21a9 https://opendata.vlci.valencia.es \u21a9 https://nodejs.org/es/ \u21a9 http://gobiernoabierto.valencia.es/es/dataset/?id=google-transit-lineas-paradas-horarios-de-autobuses \u21a9 https://github.com/calvinmetcalf/leaflet-ajax \u21a9 https://github.com/gka/chroma.js/ \u21a9","title":"Referencias"},{"location":"1_introduccion_a_las_ides/","text":"Introducci\u00f3n a las IDE's Temario Antecedentes Qu\u00e9 es una IDE? Componentes de una IDE IDEC IDEE INSPIRE Otras IDES Tradicionalmente, la obtenci\u00f3n de informaci\u00f3n geogr\u00e1fica ha estado caracterizada por una serie de dificultades (formatos, precios, d\u00f3nde buscarla...), ya que estaba muy dispersa y en diferentes formatos. No obstante, el desarrollo de tecnolog\u00edas de la informaci\u00f3n y la mejora de las comunicaciones tiene que permitir salvar todos estos obst\u00e1culos y facilitar el acceso tanto a la informaci\u00f3n del sector p\u00fablico como privado empar\u00e1ndose en unas pol\u00edticas de consenso y en un marco legal establecido. Si a todo esto le sumamos el uso de herramientas desarrolladas con tecnolog\u00edas est\u00e1ndar las posibilidades de b\u00fasqueda, acceso y intercambio de informaci\u00f3n son infinitas. La informaci\u00f3n geogr\u00e1fica es uno de los elementos m\u00e1s esenciales en la toma de decisiones, as\u00ed como uno de los m\u00e1s costosos (entre un 70 y un 80% de los costes de un proyecto SIG est\u00e1n destinados a la compra y/o mantenimiento de los datos). Esta informaci\u00f3n est\u00e1 concentrada mayoritariamente al sector p\u00fablico (de estima que entre un 80 y un 90% de la informaci\u00f3n geogr\u00e1fica es generada por administraciones p\u00fablicas). El hecho de no conocer la informaci\u00f3n disponible, hace que los datos puedan ser comprados una y otra vez por diferentes administraciones, aumentando innecesariamente el coste de los proyectos. Antecedentes En 1987, el comit\u00e9 Chorley, del Departamento de Medioambiente de Estados Unidos, concluy\u00f3 que las barreras pol\u00edticas e institucionales que restringen actualmente el uso de los SIG deben ser superadas. Esto incluye problemas de incompatibilidad por diferencias de definici\u00f3n y formatos, as\u00ed como restricciones al acceso y adquisici\u00f3n de los propios datos. En la conferencia de las Naciones Unidas sobre medio ambiente y desarrollo que tuvo lugar en en R\u00edo de Janeiro en 1992. Entre los muchos temas a debate en esta reuni\u00f3n, uno de especial relevancia fue el papel de la informaci\u00f3n geogr\u00e1fica para tratar los problemas acerca de los cuales se debat\u00eda (protecci\u00f3n medioambiental, cooperaci\u00f3n internacional, desarrollo, etc.). Qued\u00f3 claro en aquel momento que establecer mecanismos para afrontar esos problemas pasaba necesariamente por instaurar de forma paralela mecanismos que permitieran aprovechar mejor la informaci\u00f3n geogr\u00e1fica y lograr una mayor coordinaci\u00f3n entre las organizaciones estatales encargadas de su manejo. 1 El concepto IDE nace en los a\u00f1os noventa como una voluntad pol\u00edtica en Estados Unidos para garantizar la interoperabilidad entre la informaci\u00f3n geogr\u00e1fica generada por las diferentes agencias federales. La primera IDE se implant\u00f3 a mediados de los 90, cuando EEUU inici\u00f3 el desarrollo de herramientas de acceso a datos, precursoras de las IDE Nacionales, para coordinar el desarrollo, uso, intercambio y la difusi\u00f3n de la cartograf\u00eda topogr\u00e1fica y los datos espaciales relacionados. En 1994, Bill Clinton aprob\u00f3 la Orden Ejecutiva 12906 d\u00f3nde dec\u00eda: \"La informaci\u00f3n geogr\u00e1fica es vital para a promover el desarrollo econ\u00f3mico, aprovechar nuestros recursos naturales y proteger el medio ambiente. La tecnolog\u00eda moderna permite mejorar la adquisici\u00f3n, distribuci\u00f3n y utilizaci\u00f3n de datos geogr\u00e1ficos y cartogr\u00e1ficos. La Revisi\u00f3n del Desarrollo Nacional, ha recomendado que la rama ejecutiva desarrolle, en cooperaci\u00f3n con los estados, los gobiernos locales y el sector privado, una Infraestructura Nacional de Datos Espaciales para a apoyar las aplicaciones de los datos geoespaciales en el sector p\u00fablico y privado, en \u00e1reas como el transporte, el desarrollo comunitario, la agricultura, la atenci\u00f3n de emergencias, la gesti\u00f3n ambiental y la tecnolog\u00eda de informaci\u00f3n\". Otros pa\u00edses iniciaron los primeros pasos con los mismos objetivos. Los pa\u00edses que hab\u00edan implementado IDE de primera generaci\u00f3n, se replantean la iniciativa y la van actualizando y modificando, adapt\u00e1ndola a las necesidades del momento (se puede situar en el a\u00f1o 2000). Esto trajo un r\u00e1pido incremento de nuevos pa\u00edses que se implicaron en el proceso de creaci\u00f3n de infraestructuras de datos (el a\u00f1o 2002, 120 pa\u00edses hab\u00edan iniciado o iniciaban proyectos IDE) y la aparici\u00f3n de una comunidad IDE, en la cual se pod\u00edan compartir e intercambiar experiencias Qu\u00e9 es una IDE? Existen varias definiciones para describir IDE, pero una de las mas utilizada y extendida es la elaborada por la Federal Geographic Data Committee (FGDC) que la define como: Una Infraestructura de Datos Espaciales (IDE) se puede definir como un conjunto de tecnolog\u00edas, pol\u00edticas, est\u00e1ndares y recursos humanos necesarios para a adquirir, procesar, almacenar, distribuir y mejorar la utilizaci\u00f3n de la informaci\u00f3n geogr\u00e1fica - Federal Geographic Data Committee (FGDC) Una IDE (Infraestructura de Datos Espaciales) es un sistema inform\u00e1tico integrado por un conjunto de recursos (cat\u00e1logos, servidores, programas, datos, aplicaciones, p\u00e1ginas Web,...) dedicados a gestionar Informaci\u00f3n geogr\u00e1fica disponibles en Internet, que cumpla una serie de condiciones de interoperabilidad. 2 A partir de estas definiciones podemos vislumbrar que una IDE no es solo una implementaci\u00f3n tecnol\u00f3gica sino que comprende una parte muy importante de comunicaci\u00f3n, no precisamente entre servidor-servidor, sino entre Instituci\u00f3n\u2014Instituciones, departamento\u2014departamento, en definitiva persona\u2014persona para establecer los marcos de colaboraci\u00f3n para compartir, describir y acceder a los datos geogr\u00e1ficos. Visi\u00f3n global IDE Comparaci\u00f3n Conceptualmente, las Infraestructuras de datos tienen la misma finalidad que las carreteras y las autopistas: mejorar la comunicaci\u00f3n, facilitar el acceso, incrementar el comercio, etc. Infraestructura de tr\u00e1nsito Infraestructura de datos espaciales Objetivos: mejorar la accesibilidad y el uso de los coches Objetivos: mejorar el acceso, el uso de la Geoinformaci\u00f3n y evitar duplicaciones de datos Red de transporte (carreteras, caminos, puentes, etc.) Internet Veh\u00edculos Datos Ayudas: mapas, carteles, se\u00f1ales Cat\u00e1logos (datos y servicios) Conductores Usuarios Taller / Garaje (Servicios) Webservices Parking Almac\u00e9n de geodatos de los proveedores Fabricante de coches Proveedores de datos y servicios Carn\u00e9 de conducir Personal cualificado C\u00f3digo de circulaci\u00f3n Est\u00e1ndares Regulaci\u00f3n tr\u00e1nsito Pol\u00edtica + Lesgislaci\u00f3n Pol\u00edtica (Centro de control de tr\u00e1nsito) Marco institucional (Centro de Geodatos) Una buena infraestructura viaria proporciona una mejor accesibilidad, de lo que se deriva una mejor comunicaci\u00f3n entre regiones y, por tanto, un incremento del comercio. Esta es precisamente, la finalidad de las IDE: facilitar el acceso y el uso de la informaci\u00f3n geogr\u00e1fica y fomentar su comercio. Componentes de una IDE Una IDE est\u00e1 compuesta de 4 elementos fundamentales: Marco institucional Organizaci\u00f3n Datos y Metadatos Descriptores de les datos Geoservicios Visualizaci\u00f3n y acceso a los datos Usuarios y colaboradores Marco institucional Para que una IDE pueda prosperar tiene que contar con un suporte institucional firme que garantice su impulso inicial. Este suporte se tiene que plasmar con un marco legal adecuado, que anime a las diferentes administraciones p\u00fablicas o entidades a participar en las activitades de la IDE. Los datos y sus descriptores Las administraciones p\u00fablicas son las propietarias de la mayor\u00eda de la informaci\u00f3n geogr\u00e1fica de referencia para lo cual, asegurando su implicaci\u00f3n garantizamos una cartograf\u00eda de base esencial para el desarrollo de la IDE. Los datos, por si solos, no nos aportan demasiada informaci\u00f3n. Por este motivo, es necesaria su descripci\u00f3n. Los metadatos describen el contenido y las caracter\u00edsticas de los datos, aportando una informaci\u00f3n muy valiosa que ayuda a \u201ccontextualizar\u201d el dato, y en ocasiones, facilitar su acceso. Estos metadatos tienen que ser almacenados en un Cat\u00e1logo on line, consultable para a cualquier usuario, y descritos seg\u00fan unos est\u00e1ndares que aportan las pautas de c\u00f3mo y qu\u00e9 informaci\u00f3n hay que dar en cada caso. La visualizaci\u00f3n y el acceso a los datos El intercanvio de informaci\u00f3n y la interoperatividad de los sistemas son dos conceptos clave en una IDE. Ambos se pueden conseguir gracias a los est\u00e1ndares. OGC ha desarrollado una serie de especificaciones est\u00e1ndar que permiten a dos sistemas diferentes, con arquitecturas y formatos de datos diversos combinar cartograf\u00eda sin ning\u00fan esfuerzo por parte del usuario. Para f\u00e1cilitar la visualizaci\u00f3n y el acceso a los datos los encargados del desarrollo de la IDE generalmente implementan un Geoportal que incluye entre otras cosas: Metadatos (descripci\u00f3n del contenido, la cualidad y otras caracter\u00edsticas de los datos) Cat\u00e1logo (publicaci\u00f3n en Internet de los metadatos de datos, servicios y esquemas) Servicio de acceso a datos y servicios (clientes, visores) Servidores de mapas con proveedores de informaci\u00f3n Servicios de geoprocesamiento (procesos inform\u00e1ticos que manipulan y transforman datos geoespaciales: transformaciones de coordenadas, de proyecciones, an\u00e1lisis espacial...) Conexiones a otras IDE's. Los usuarios y colaboradores Para que una IDE se pueda considerar como tal, tiene que haber unos usuarios que la usen, en este sentido la tarea de difusi\u00f3n es muy importante. A medida que se incrementa su uso, las empresas empiezan a ver las posibilidades comerciales y a implicarse en el proyecto, acelerando as\u00ed el crecimiento de la IDE. Principios en que se basa el dearrollo de una IDE Datos recogidos una vez y mantenidos en el nivel donde se logra m\u00e1xima efectividad Quien genera, y sobre todo mantiene, un tipo de datos debe encargarse de organizarlos en una base de datos y facilitar el acceso a ellos mediante los servicios adecuados No deben duplicarse los mismos datos en bases de datos distintas que no aseguren exactamente el mismo nivel de actualizaci\u00f3n Debe ser posible combinar IG con total continuidad para un \u00e1mbito territorial extenso desde fuentes diversas La informaci\u00f3n geogr\u00e1fica en un \u00e1mbito territorial debe basarse en una informaci\u00f3n geogr\u00e1fica de referencia com\u00fan, y acorde con la precisi\u00f3n de la informaci\u00f3n geogr\u00e1fica y en un \u00fanico Sistema Geod\u00e9sico de referencia Debe ser posible superponer capas de informaci\u00f3n geogr\u00e1fica de distintas tem\u00e1ticas y procedencias Debe ser posible compartir la IG entre usuarios y aplicaciones Debe ser posible que la informaci\u00f3n recogida en un nivel o sector sea compartida por los otros Debe ser f\u00e1cil descubrir la informaci\u00f3n geogr\u00e1fica disponible, y en qu\u00e9 condiciones puede conseguirse y usarse Metadatos Calidad Normas comunes En un escenario \u00f3ptimo, todo usuario de una IDE deber\u00eda poder descubrir, por ejemplo, que informaci\u00f3n geogr\u00e1fica existe en zona concreta del territorio, visualizar esta informaci\u00f3n y finalmente, si es de su inter\u00e9s, descargarla. Para llegar a esta meta, toda IDE que se precie debe: Orientar su arquitectura a servicios (SOA) Uno de los principios b\u00e1sicos de toda IDE es la no replicaci\u00f3n de datos geogr\u00e1ficos ni la creaci\u00f3n de grandes bases de datos centralizadas. Una IDE debe fomentar un modelo distribuido d\u00f3nde cada departamento o ente se responsabilice de sus datos y se encargue de describirlos y ponerlos a disposici\u00f3n de los dem\u00e1s. Implementar aplicaciones que posibiliten descubrir, visualizar y procesar informaci\u00f3n geogr\u00e1fica. Entre estas aplicaciones podr\u00edamos definir un n\u00facleo presente en toda IDE: un cat\u00e1logo de metadatos, servidores de mapas y un conjunto de servicios geogr\u00e1ficos. Adoptar los est\u00e1ndares de interoperabilidad geoespacial para facilitar la comunicaci\u00f3n entre componentes. Para la descripci\u00f3n de los metadatos se basa en est\u00e1ndares ISO de la familia 19, dedicada al mundo geospacial. Pero a nivel de interfaces de comunicaci\u00f3n entre servidores y entre clientes (ej. Un navegador web) y servidores existe un consorcio llamado OpenGeospatial (OGC) encargado de definir las especificaciones utilizadas. Podr\u00edamos que decir que el papel que juega el consorcio W3C en cuanto a la estandarizaci\u00f3n de la Word Wide Web (www) es parecido al de OGC dentro del mundo geoespacial. La utilidad de las IDE y sus ventajas Cuando un usuario quiere acceder a informaci\u00f3n geogr\u00e1fica se puede encontrar con una situaci\u00f3n ca\u00f3tica, al no saber d\u00f3nde ir a buscarla. A nivel de cooperaci\u00f3n entre administraciones y empresas, la situaci\u00f3n es tambi\u00e9n muy compleja, a causa del gran n\u00famero de contactos que hay que realizar para obtener estos datos y los permisos para utilizarlos. En un entorno IDE todo es m\u00e1s sencillo. Gracias a la catalogaci\u00f3n de los datos y mediante los servidores de cat\u00e1logo los usuarios pueden localizar y acceder a la informaci\u00f3n geogr\u00e1fica existente. La IDE se encarga tambi\u00e9n de establecer acuerdos con las administraciones con el objetivo que estas permitan la difusi\u00f3n de su informaci\u00f3n mediante un servicio de webmapping . Ambos servicios (servidor de cat\u00e1logo y webmapping) tienen que ser accesibles a trav\u00e9s de un \u00fanico portal web. Por tanto, el uso de las IDE mejora considerablemente la din\u00e1mica del sector de la geoinformaci\u00f3n. Otras ventajas de las IDE son: Facilita la toma de decisiones Reduce esfuerzos y costes Proporciona datos mejores y m\u00e1s actualizados Apoya la creaci\u00f3n de nuevas oportunidades de negocio. Hay que tener presente que una IDE no se tiene que ver s\u00f3lo desde la vertiente tecnol\u00f3gica sino que existe tambi\u00e9n una vertiente social, en que los usuarios (el sector p\u00fablico, el privado y la poblaci\u00f3n) tienen que dar su opini\u00f3n, a partir de la cual se podr\u00e1n determinar las estrategias a seguir. En el proceso de implantaci\u00f3n de una IDE tambi\u00e9n hay que superar obst\u00e1culos t\u00e9cnicos (no disponibilidad de datos, de est\u00e1ndares, metadatos, redes de comunicaci\u00f3n, banda ancha...), econ\u00f3micos, socio-culturales (conocimiento, educaci\u00f3n, seguridad, libertad de acceso...), pol\u00edticos-legales (datos delicados, propiedad intelectual...) y d\u00e9ficit de suporte (no se conoce la finalidad y el valor de las IDE). Las IDE, adem\u00e1s de mantener v\u00edas de cooperaci\u00f3n y relaciones con el sector p\u00fablico y privado de la su regi\u00f3n, tienen que hacerlo tambi\u00e9n tanto con las IDE de su nivel como con las de otros niveles Niveles de desarrollo de una IDE Tenemos que pensar que una IDE conlleva un factor multi-escalar en su implementaci\u00f3n, esta puede ser implementada a nivel europeo, nivel estatal, nivel regional e incluso a nivel municipal. Cada nivel tiene la responsabilidad de interoperar con el resto de niveles Ejemplos de niveles de desarrollo de una IDE Global - GSDI (Global Spatial Data Infrastructure) http://gsdiassociation.org/ Europeo - INSPIRE INfraestructure for SPatial InfoRmation in Europe http://inspire-geoportal.ec.europa.eu/ Nacional - IDEE (Infraestructura de Datos Espaciales de Espa\u00f1a) http://idee.es/ Regional - IDEC (Infraestructura de Dades Espacials de Catalunya) http://www.ide.cat Local - Barcelona http://w133.bcn.cat/geoportalbcn/GeoPortal.aspx?lang=es IDEC La IDEC (Infraestructura de Dades Espacials de Catalunya) es una iniciativa creada el a\u00f1o 2002 para desarrollar y mantener una Infraestructura de Datos Espaciales (IDE) en el territorio de Catalunya. Esta infraestructura pretende facilitar y mejorar el acceso a la informaci\u00f3n y los servicios geogr\u00e1ficos disponibles, poniendo al alcance de los usuarios herramientas para buscar, descubrir, consultar y descargar estos recursos mediante la web, para utilizarlos y explotarlos posteriormente. El proyecto se hace posible gracias a la participaci\u00f3n activa y colaborativa de los diferentes tipos de actores involucrados: los productores y/o proveedores de informaci\u00f3n geogr\u00e1fica (o espacial) y los propios usuarios. IDEE La IDEE (Infraestructura de Datos Espaciales de Espa\u00f1a) tiene como objetivo integrar a trav\u00e9s de Internet los datos, metadatos, servicios e informaci\u00f3n de tipo geogr\u00e1fico que se producen en Espa\u00f1a, a nivel estatal, auton\u00f3mico y local, cumpliendo una serie de condiciones de interoperabilidad (normas, protocolos, especificaciones) y conforme a sus respectivos marcos legales. El fruto de este trabajo es el proyecto IDEE. La IDEE arranc\u00f3 en 2002 cuando la Comisi\u00f3n Permanente del Consejo Superior Geogr\u00e1fico aprob\u00f3 el 10 abril la puesta en marcha de una Infraestructura Nacional de Datos Espaciales. IDEE es el resultado de la integraci\u00f3n, en primer lugar, de todas las IDE establecidas por los productores oficiales de datos a nivel tanto estatal como auton\u00f3mico y local, y en segundo lugar, de todo tipo de infraestructuras sectoriales y privadas. En cada C.C.A.A y organismo de la Administraci\u00f3n General del Estado (AGE) hay un representante, responsable de la implantaci\u00f3n de la IDE en su C.C.A.A y en el organismo de la AGE. Marco legal En Espa\u00f1a la LISIGE se aplica a todos los datos geogr\u00e1ficos que cumplan las siguientes condiciones Se refieran a una zona geogr\u00e1fica del territorio nacional, el mar territorial, la zona contigua, la plataforma continental y la zona exclusiva econ\u00f3mica exclusiva, generada o bajo responsabilidad de las Administraciones p\u00fablicas y sobre la que el Estado tenga jurisdicci\u00f3n Est\u00e9n en formato electr\u00f3nico Su producci\u00f3n y mantenimiento sea competencia de una Administraci\u00f3n u organismo del sector p\u00fablico Se refieran a Informaci\u00f3n Geogr\u00e1fica de Referencia o a Datos Tem\u00e1ticos Fundamentales o a Datos Tem\u00e1ticos Generales existentes, salvaguardando en este caso los intereses prioritarios de la defensa nacional INSPIRE INSPIRE (INfrastructure for SPatial InfoRmation in Europe) tiene por objetivo hacer disponible una informaci\u00f3n geogr\u00e1fica de calidad, armonizada y relevante para apoyar la formulaci\u00f3n, la implementaci\u00f3n, la monitorizaci\u00f3n y la evaluaci\u00f3n de las pol\u00edticas comunitarias con un impacto o dimensi\u00f3n territorial. INSPIRE es una iniciativa legal de la UE que dirigir\u00e1 protocolos y est\u00e1ndares, aspectos de coordinaci\u00f3n y organizaci\u00f3n, pol\u00edticas de datos incluyendo el acceso a los datos y la creaci\u00f3n y el mantenimiento de la informaci\u00f3n espacial. El 17 de noviembre de 2003, el Parlamento Europeo aprob\u00f3 la Directiva 2003/98 CE, en lo referente a la reutilizaci\u00f3n de la informaci\u00f3n del sector p\u00fablico. Su finalidad es fijar un marco legal que armonice el uso y la explotaci\u00f3n de la informaci\u00f3n del sector p\u00fablico (condiciones de reutilizaci\u00f3n, formatos disponibles, principios de tarificaci\u00f3n, transparencia, etc.), fomentando as\u00ed un mercado interior entre todos los estados miembros. La nueva directiva se dirige claramente a facilitar informaci\u00f3n desde las Entidades P\u00fablicas hacia el sector privado, que puede darle un amplio valor a\u00f1adido a. De manera especial favorecer\u00e1 la difusi\u00f3n de informaci\u00f3n geogr\u00e1fica, dado que las administraciones p\u00fablicas son el principal generador de este tipo de informaci\u00f3n. Lo que puede reforzar iniciativas IDE, entre muchas de otras. Para asegurar que las infraestructuras de datos espaciales de los Estados miembros sean compatibles e interoperables en un contexto comunitario y transfronterizo, la Directiva exige que se adopten Normas de Ejecuci\u00f3n comunes Implementing Rules) espec\u00edficas para las siguientes \u00e1reas metadatos, conjuntos de datos, servicios de red, servicios de datos espaciales, datos y servicios de uso compartido y seguimiento e informes Estas normas son de obligado cumplimiento en cada uno de los pa\u00edses de la Uni\u00f3n La Directiva INSPIRE se aplica en diferentes etapas hasta el 2021 que deber\u00e1 tener aplicaci\u00f3n plena Es el primer paso de una amplia iniciativa multisectorial, que inicialmente se centrar\u00e1 en la informaci\u00f3n espacial necesaria para las pol\u00edticas medio ambientales y que estar\u00e1 abierta a las necesidades de otras \u00e1reas pol\u00edticas como la agricultura y el transporte. La situaci\u00f3n general respecto a la informaci\u00f3n espacial en Europa es de fragmentaci\u00f3n de datos y fuentes. Hay lagunas en la disponibilidad de los datos, carencia de harmonizaci\u00f3n entre conjuntos de datos en las diferentes escalas y sistemas de referencia y duplicaci\u00f3n de la informaci\u00f3n. Estos problemas hacen dif\u00edcil la identificaci\u00f3n, el acceso y el uso de los datos disponibles. Afortunadamente, est\u00e1 creciendo la conciencia sobre la necesidad de una informaci\u00f3n georeferenciada de calidad para entender mejor las relaciones humanas con su entorno. La iniciativa tiene la intenci\u00f3n de crear una infraestructura europea de datos espaciales que d\u00e9 servicios de informaci\u00f3n espacial integrada a los usuarios. Estos servicios tendr\u00e1n que permitir a los usuarios identificar y acceder a la informaci\u00f3n geogr\u00e1fica de muy variadas fuentes, garantizando la interoperatividad. Los posibles servicios son la visualizaci\u00f3n de capas de informaci\u00f3n, la superposici\u00f3n de informaci\u00f3n procedente de diferentes fuentes, el an\u00e1lisis espacial y temporal, etc. Principios de INSPIRE Los datos tienen que recogerse una sola vez y conservarse en el nivel donde resulten m\u00e1s eficaces. Tiene que ser posible combinar, sin problemas de continuidad, la informaci\u00f3n geogr\u00e1fica procedente de diferentes fuentes europeas y ponerla al alcance de los usuarios y aplicaciones. La informaci\u00f3n recogida a un nivel tiene que poder ser compartida a todos los niveles, la informaci\u00f3n a gran escala para investigaciones detalladas, y la de peque\u00f1a escala para finalidades estrat\u00e9gicas. La informaci\u00f3n geogr\u00e1fica necesaria a todos los niveles tiene que ser abundante sin limitar su uso extensivo Tiene que ser sencillo descubrir qu\u00e9 informaci\u00f3n geogr\u00e1fica est\u00e1 disponible, si cubre las necesidades para un uso determinado y bajo qu\u00e9 condiciones se puede adquirir y utilizar Los datos geogr\u00e1ficos tienen que ser f\u00e1ciles de entender y de interpretar porque tienen que estar adecuadamente documentados Temas INSPIRE Annex I Coordinate reference systems Geographical grid systems Geographical names Administrative units Addresses Cadastral parcels Transport networks Hydrography Protected sites Annex II Elevation Land cover Orthoimagery Geology Annex III Statistical units Buildings Soil Land use Human health and safety Utility and governmental services Environmental monitoring Facilities Production and industrial facilities Agricultural and aquaculture facilities Population distribution and demography Area management / restriction / regulation zones & reporting units Natural risk zones Atmospheric conditions Meteorological geographical features Oceanographic geographical features Sea regions Bio-geographical regions Habitats and biotopes Species distribution Energy Resources Mineral Resources Otras IDES GSDI (Global Spatial Data Infrastructure) Convertida en asociaci\u00f3n el a\u00f1o 2004, esta iniciativa empez\u00f3 a mediados de los 90 con el objetivo de fomentar la captura, el procesamiento, la integraci\u00f3n y la compartici\u00f3n de informaci\u00f3n y datos espaciales, utilizando est\u00e1ndares comunes y t\u00e9cnicas y sistemas interoperables, accesibles v\u00eda web. La GSDI organiza conferencias de forma regular. La primera se celebr\u00f3 el a\u00f1o 95 en Bonn, d\u00f3nde s\u00f3lo fueron invitados un peque\u00f1o n\u00famero de asistentes. En la conferencia del a\u00f1o 97, definieron la GSDI c\u00f3mo: \u201c...las pol\u00edticas, misiones organizativas, datos, tecnolog\u00edas, est\u00e1ndares, mecanismos de distribuci\u00f3n y recursos financieros y humanos para asegurar que no se impida lograr los objetivos, a aquellos que trabajan a escala global y local\u201d. Tiene por objetivo fomentar la captura, el procesamiento, la integraci\u00f3n, el almacenamiento y el intercambio de datos e informaci\u00f3n espacial utilizando est\u00e1ndares comunes y t\u00e9cnicas y sistemas interoperables v\u00eda web. Para lograrlo, es necesario poner un especial \u00e9nfasis en los m\u00e9todos de difusi\u00f3n, educaci\u00f3n, recursos, pol\u00edticas y aspectos legales relacionados con su desarrollo. Ejemplos de otras IDES Internacional Geoportal ONU Nacional IGN France Estados Unidos Chile Regional IDE Canarias IDE Andaluc\u00eda Local C\u00e1ceres Referencias https://github.com/volaya/libro-sig/releases/download/v2.0/Libro_SIG.pdf \u21a9 https://www.miteco.gob.es/es/cartografia-y-sig/ide/presentacion/que-es-ide.aspx \u21a9","title":"1. Introducci\u00f3n a las IDE's"},{"location":"1_introduccion_a_las_ides/#introduccion-a-las-ides","text":"Temario Antecedentes Qu\u00e9 es una IDE? Componentes de una IDE IDEC IDEE INSPIRE Otras IDES Tradicionalmente, la obtenci\u00f3n de informaci\u00f3n geogr\u00e1fica ha estado caracterizada por una serie de dificultades (formatos, precios, d\u00f3nde buscarla...), ya que estaba muy dispersa y en diferentes formatos. No obstante, el desarrollo de tecnolog\u00edas de la informaci\u00f3n y la mejora de las comunicaciones tiene que permitir salvar todos estos obst\u00e1culos y facilitar el acceso tanto a la informaci\u00f3n del sector p\u00fablico como privado empar\u00e1ndose en unas pol\u00edticas de consenso y en un marco legal establecido. Si a todo esto le sumamos el uso de herramientas desarrolladas con tecnolog\u00edas est\u00e1ndar las posibilidades de b\u00fasqueda, acceso y intercambio de informaci\u00f3n son infinitas. La informaci\u00f3n geogr\u00e1fica es uno de los elementos m\u00e1s esenciales en la toma de decisiones, as\u00ed como uno de los m\u00e1s costosos (entre un 70 y un 80% de los costes de un proyecto SIG est\u00e1n destinados a la compra y/o mantenimiento de los datos). Esta informaci\u00f3n est\u00e1 concentrada mayoritariamente al sector p\u00fablico (de estima que entre un 80 y un 90% de la informaci\u00f3n geogr\u00e1fica es generada por administraciones p\u00fablicas). El hecho de no conocer la informaci\u00f3n disponible, hace que los datos puedan ser comprados una y otra vez por diferentes administraciones, aumentando innecesariamente el coste de los proyectos.","title":"Introducci\u00f3n a las IDE's"},{"location":"1_introduccion_a_las_ides/#antecedentes","text":"En 1987, el comit\u00e9 Chorley, del Departamento de Medioambiente de Estados Unidos, concluy\u00f3 que las barreras pol\u00edticas e institucionales que restringen actualmente el uso de los SIG deben ser superadas. Esto incluye problemas de incompatibilidad por diferencias de definici\u00f3n y formatos, as\u00ed como restricciones al acceso y adquisici\u00f3n de los propios datos. En la conferencia de las Naciones Unidas sobre medio ambiente y desarrollo que tuvo lugar en en R\u00edo de Janeiro en 1992. Entre los muchos temas a debate en esta reuni\u00f3n, uno de especial relevancia fue el papel de la informaci\u00f3n geogr\u00e1fica para tratar los problemas acerca de los cuales se debat\u00eda (protecci\u00f3n medioambiental, cooperaci\u00f3n internacional, desarrollo, etc.). Qued\u00f3 claro en aquel momento que establecer mecanismos para afrontar esos problemas pasaba necesariamente por instaurar de forma paralela mecanismos que permitieran aprovechar mejor la informaci\u00f3n geogr\u00e1fica y lograr una mayor coordinaci\u00f3n entre las organizaciones estatales encargadas de su manejo. 1 El concepto IDE nace en los a\u00f1os noventa como una voluntad pol\u00edtica en Estados Unidos para garantizar la interoperabilidad entre la informaci\u00f3n geogr\u00e1fica generada por las diferentes agencias federales. La primera IDE se implant\u00f3 a mediados de los 90, cuando EEUU inici\u00f3 el desarrollo de herramientas de acceso a datos, precursoras de las IDE Nacionales, para coordinar el desarrollo, uso, intercambio y la difusi\u00f3n de la cartograf\u00eda topogr\u00e1fica y los datos espaciales relacionados. En 1994, Bill Clinton aprob\u00f3 la Orden Ejecutiva 12906 d\u00f3nde dec\u00eda: \"La informaci\u00f3n geogr\u00e1fica es vital para a promover el desarrollo econ\u00f3mico, aprovechar nuestros recursos naturales y proteger el medio ambiente. La tecnolog\u00eda moderna permite mejorar la adquisici\u00f3n, distribuci\u00f3n y utilizaci\u00f3n de datos geogr\u00e1ficos y cartogr\u00e1ficos. La Revisi\u00f3n del Desarrollo Nacional, ha recomendado que la rama ejecutiva desarrolle, en cooperaci\u00f3n con los estados, los gobiernos locales y el sector privado, una Infraestructura Nacional de Datos Espaciales para a apoyar las aplicaciones de los datos geoespaciales en el sector p\u00fablico y privado, en \u00e1reas como el transporte, el desarrollo comunitario, la agricultura, la atenci\u00f3n de emergencias, la gesti\u00f3n ambiental y la tecnolog\u00eda de informaci\u00f3n\". Otros pa\u00edses iniciaron los primeros pasos con los mismos objetivos. Los pa\u00edses que hab\u00edan implementado IDE de primera generaci\u00f3n, se replantean la iniciativa y la van actualizando y modificando, adapt\u00e1ndola a las necesidades del momento (se puede situar en el a\u00f1o 2000). Esto trajo un r\u00e1pido incremento de nuevos pa\u00edses que se implicaron en el proceso de creaci\u00f3n de infraestructuras de datos (el a\u00f1o 2002, 120 pa\u00edses hab\u00edan iniciado o iniciaban proyectos IDE) y la aparici\u00f3n de una comunidad IDE, en la cual se pod\u00edan compartir e intercambiar experiencias","title":"Antecedentes"},{"location":"1_introduccion_a_las_ides/#que-es-una-ide","text":"Existen varias definiciones para describir IDE, pero una de las mas utilizada y extendida es la elaborada por la Federal Geographic Data Committee (FGDC) que la define como: Una Infraestructura de Datos Espaciales (IDE) se puede definir como un conjunto de tecnolog\u00edas, pol\u00edticas, est\u00e1ndares y recursos humanos necesarios para a adquirir, procesar, almacenar, distribuir y mejorar la utilizaci\u00f3n de la informaci\u00f3n geogr\u00e1fica - Federal Geographic Data Committee (FGDC) Una IDE (Infraestructura de Datos Espaciales) es un sistema inform\u00e1tico integrado por un conjunto de recursos (cat\u00e1logos, servidores, programas, datos, aplicaciones, p\u00e1ginas Web,...) dedicados a gestionar Informaci\u00f3n geogr\u00e1fica disponibles en Internet, que cumpla una serie de condiciones de interoperabilidad. 2 A partir de estas definiciones podemos vislumbrar que una IDE no es solo una implementaci\u00f3n tecnol\u00f3gica sino que comprende una parte muy importante de comunicaci\u00f3n, no precisamente entre servidor-servidor, sino entre Instituci\u00f3n\u2014Instituciones, departamento\u2014departamento, en definitiva persona\u2014persona para establecer los marcos de colaboraci\u00f3n para compartir, describir y acceder a los datos geogr\u00e1ficos. Visi\u00f3n global IDE","title":"Qu\u00e9 es una IDE?"},{"location":"1_introduccion_a_las_ides/#comparacion","text":"Conceptualmente, las Infraestructuras de datos tienen la misma finalidad que las carreteras y las autopistas: mejorar la comunicaci\u00f3n, facilitar el acceso, incrementar el comercio, etc. Infraestructura de tr\u00e1nsito Infraestructura de datos espaciales Objetivos: mejorar la accesibilidad y el uso de los coches Objetivos: mejorar el acceso, el uso de la Geoinformaci\u00f3n y evitar duplicaciones de datos Red de transporte (carreteras, caminos, puentes, etc.) Internet Veh\u00edculos Datos Ayudas: mapas, carteles, se\u00f1ales Cat\u00e1logos (datos y servicios) Conductores Usuarios Taller / Garaje (Servicios) Webservices Parking Almac\u00e9n de geodatos de los proveedores Fabricante de coches Proveedores de datos y servicios Carn\u00e9 de conducir Personal cualificado C\u00f3digo de circulaci\u00f3n Est\u00e1ndares Regulaci\u00f3n tr\u00e1nsito Pol\u00edtica + Lesgislaci\u00f3n Pol\u00edtica (Centro de control de tr\u00e1nsito) Marco institucional (Centro de Geodatos) Una buena infraestructura viaria proporciona una mejor accesibilidad, de lo que se deriva una mejor comunicaci\u00f3n entre regiones y, por tanto, un incremento del comercio. Esta es precisamente, la finalidad de las IDE: facilitar el acceso y el uso de la informaci\u00f3n geogr\u00e1fica y fomentar su comercio.","title":"Comparaci\u00f3n"},{"location":"1_introduccion_a_las_ides/#componentes-de-una-ide","text":"Una IDE est\u00e1 compuesta de 4 elementos fundamentales: Marco institucional Organizaci\u00f3n Datos y Metadatos Descriptores de les datos Geoservicios Visualizaci\u00f3n y acceso a los datos Usuarios y colaboradores","title":"Componentes de una IDE"},{"location":"1_introduccion_a_las_ides/#marco-institucional","text":"Para que una IDE pueda prosperar tiene que contar con un suporte institucional firme que garantice su impulso inicial. Este suporte se tiene que plasmar con un marco legal adecuado, que anime a las diferentes administraciones p\u00fablicas o entidades a participar en las activitades de la IDE.","title":"Marco institucional"},{"location":"1_introduccion_a_las_ides/#los-datos-y-sus-descriptores","text":"Las administraciones p\u00fablicas son las propietarias de la mayor\u00eda de la informaci\u00f3n geogr\u00e1fica de referencia para lo cual, asegurando su implicaci\u00f3n garantizamos una cartograf\u00eda de base esencial para el desarrollo de la IDE. Los datos, por si solos, no nos aportan demasiada informaci\u00f3n. Por este motivo, es necesaria su descripci\u00f3n. Los metadatos describen el contenido y las caracter\u00edsticas de los datos, aportando una informaci\u00f3n muy valiosa que ayuda a \u201ccontextualizar\u201d el dato, y en ocasiones, facilitar su acceso. Estos metadatos tienen que ser almacenados en un Cat\u00e1logo on line, consultable para a cualquier usuario, y descritos seg\u00fan unos est\u00e1ndares que aportan las pautas de c\u00f3mo y qu\u00e9 informaci\u00f3n hay que dar en cada caso.","title":"Los datos y sus descriptores"},{"location":"1_introduccion_a_las_ides/#la-visualizacion-y-el-acceso-a-los-datos","text":"El intercanvio de informaci\u00f3n y la interoperatividad de los sistemas son dos conceptos clave en una IDE. Ambos se pueden conseguir gracias a los est\u00e1ndares. OGC ha desarrollado una serie de especificaciones est\u00e1ndar que permiten a dos sistemas diferentes, con arquitecturas y formatos de datos diversos combinar cartograf\u00eda sin ning\u00fan esfuerzo por parte del usuario. Para f\u00e1cilitar la visualizaci\u00f3n y el acceso a los datos los encargados del desarrollo de la IDE generalmente implementan un Geoportal que incluye entre otras cosas: Metadatos (descripci\u00f3n del contenido, la cualidad y otras caracter\u00edsticas de los datos) Cat\u00e1logo (publicaci\u00f3n en Internet de los metadatos de datos, servicios y esquemas) Servicio de acceso a datos y servicios (clientes, visores) Servidores de mapas con proveedores de informaci\u00f3n Servicios de geoprocesamiento (procesos inform\u00e1ticos que manipulan y transforman datos geoespaciales: transformaciones de coordenadas, de proyecciones, an\u00e1lisis espacial...) Conexiones a otras IDE's.","title":"La visualizaci\u00f3n y el acceso a los datos"},{"location":"1_introduccion_a_las_ides/#los-usuarios-y-colaboradores","text":"Para que una IDE se pueda considerar como tal, tiene que haber unos usuarios que la usen, en este sentido la tarea de difusi\u00f3n es muy importante. A medida que se incrementa su uso, las empresas empiezan a ver las posibilidades comerciales y a implicarse en el proyecto, acelerando as\u00ed el crecimiento de la IDE.","title":"Los usuarios y colaboradores"},{"location":"1_introduccion_a_las_ides/#principios-en-que-se-basa-el-dearrollo-de-una-ide","text":"Datos recogidos una vez y mantenidos en el nivel donde se logra m\u00e1xima efectividad Quien genera, y sobre todo mantiene, un tipo de datos debe encargarse de organizarlos en una base de datos y facilitar el acceso a ellos mediante los servicios adecuados No deben duplicarse los mismos datos en bases de datos distintas que no aseguren exactamente el mismo nivel de actualizaci\u00f3n Debe ser posible combinar IG con total continuidad para un \u00e1mbito territorial extenso desde fuentes diversas La informaci\u00f3n geogr\u00e1fica en un \u00e1mbito territorial debe basarse en una informaci\u00f3n geogr\u00e1fica de referencia com\u00fan, y acorde con la precisi\u00f3n de la informaci\u00f3n geogr\u00e1fica y en un \u00fanico Sistema Geod\u00e9sico de referencia Debe ser posible superponer capas de informaci\u00f3n geogr\u00e1fica de distintas tem\u00e1ticas y procedencias Debe ser posible compartir la IG entre usuarios y aplicaciones Debe ser posible que la informaci\u00f3n recogida en un nivel o sector sea compartida por los otros Debe ser f\u00e1cil descubrir la informaci\u00f3n geogr\u00e1fica disponible, y en qu\u00e9 condiciones puede conseguirse y usarse Metadatos Calidad Normas comunes En un escenario \u00f3ptimo, todo usuario de una IDE deber\u00eda poder descubrir, por ejemplo, que informaci\u00f3n geogr\u00e1fica existe en zona concreta del territorio, visualizar esta informaci\u00f3n y finalmente, si es de su inter\u00e9s, descargarla. Para llegar a esta meta, toda IDE que se precie debe:","title":"Principios en que se basa el dearrollo de una IDE"},{"location":"1_introduccion_a_las_ides/#orientar-su-arquitectura-a-servicios-soa","text":"Uno de los principios b\u00e1sicos de toda IDE es la no replicaci\u00f3n de datos geogr\u00e1ficos ni la creaci\u00f3n de grandes bases de datos centralizadas. Una IDE debe fomentar un modelo distribuido d\u00f3nde cada departamento o ente se responsabilice de sus datos y se encargue de describirlos y ponerlos a disposici\u00f3n de los dem\u00e1s.","title":"Orientar su arquitectura a servicios (SOA)"},{"location":"1_introduccion_a_las_ides/#implementar-aplicaciones-que-posibiliten-descubrir-visualizar-y-procesar-informacion-geografica","text":"Entre estas aplicaciones podr\u00edamos definir un n\u00facleo presente en toda IDE: un cat\u00e1logo de metadatos, servidores de mapas y un conjunto de servicios geogr\u00e1ficos.","title":"Implementar aplicaciones que posibiliten descubrir, visualizar y procesar informaci\u00f3n geogr\u00e1fica."},{"location":"1_introduccion_a_las_ides/#adoptar-los-estandares-de-interoperabilidad-geoespacial-para-facilitar-la-comunicacion-entre-componentes","text":"Para la descripci\u00f3n de los metadatos se basa en est\u00e1ndares ISO de la familia 19, dedicada al mundo geospacial. Pero a nivel de interfaces de comunicaci\u00f3n entre servidores y entre clientes (ej. Un navegador web) y servidores existe un consorcio llamado OpenGeospatial (OGC) encargado de definir las especificaciones utilizadas. Podr\u00edamos que decir que el papel que juega el consorcio W3C en cuanto a la estandarizaci\u00f3n de la Word Wide Web (www) es parecido al de OGC dentro del mundo geoespacial.","title":"Adoptar los est\u00e1ndares de interoperabilidad geoespacial para facilitar la comunicaci\u00f3n entre componentes."},{"location":"1_introduccion_a_las_ides/#la-utilidad-de-las-ide-y-sus-ventajas","text":"Cuando un usuario quiere acceder a informaci\u00f3n geogr\u00e1fica se puede encontrar con una situaci\u00f3n ca\u00f3tica, al no saber d\u00f3nde ir a buscarla. A nivel de cooperaci\u00f3n entre administraciones y empresas, la situaci\u00f3n es tambi\u00e9n muy compleja, a causa del gran n\u00famero de contactos que hay que realizar para obtener estos datos y los permisos para utilizarlos. En un entorno IDE todo es m\u00e1s sencillo. Gracias a la catalogaci\u00f3n de los datos y mediante los servidores de cat\u00e1logo los usuarios pueden localizar y acceder a la informaci\u00f3n geogr\u00e1fica existente. La IDE se encarga tambi\u00e9n de establecer acuerdos con las administraciones con el objetivo que estas permitan la difusi\u00f3n de su informaci\u00f3n mediante un servicio de webmapping . Ambos servicios (servidor de cat\u00e1logo y webmapping) tienen que ser accesibles a trav\u00e9s de un \u00fanico portal web. Por tanto, el uso de las IDE mejora considerablemente la din\u00e1mica del sector de la geoinformaci\u00f3n. Otras ventajas de las IDE son: Facilita la toma de decisiones Reduce esfuerzos y costes Proporciona datos mejores y m\u00e1s actualizados Apoya la creaci\u00f3n de nuevas oportunidades de negocio. Hay que tener presente que una IDE no se tiene que ver s\u00f3lo desde la vertiente tecnol\u00f3gica sino que existe tambi\u00e9n una vertiente social, en que los usuarios (el sector p\u00fablico, el privado y la poblaci\u00f3n) tienen que dar su opini\u00f3n, a partir de la cual se podr\u00e1n determinar las estrategias a seguir. En el proceso de implantaci\u00f3n de una IDE tambi\u00e9n hay que superar obst\u00e1culos t\u00e9cnicos (no disponibilidad de datos, de est\u00e1ndares, metadatos, redes de comunicaci\u00f3n, banda ancha...), econ\u00f3micos, socio-culturales (conocimiento, educaci\u00f3n, seguridad, libertad de acceso...), pol\u00edticos-legales (datos delicados, propiedad intelectual...) y d\u00e9ficit de suporte (no se conoce la finalidad y el valor de las IDE). Las IDE, adem\u00e1s de mantener v\u00edas de cooperaci\u00f3n y relaciones con el sector p\u00fablico y privado de la su regi\u00f3n, tienen que hacerlo tambi\u00e9n tanto con las IDE de su nivel como con las de otros niveles","title":"La utilidad de las IDE y sus ventajas"},{"location":"1_introduccion_a_las_ides/#niveles-de-desarrollo-de-una-ide","text":"Tenemos que pensar que una IDE conlleva un factor multi-escalar en su implementaci\u00f3n, esta puede ser implementada a nivel europeo, nivel estatal, nivel regional e incluso a nivel municipal. Cada nivel tiene la responsabilidad de interoperar con el resto de niveles Ejemplos de niveles de desarrollo de una IDE Global - GSDI (Global Spatial Data Infrastructure) http://gsdiassociation.org/ Europeo - INSPIRE INfraestructure for SPatial InfoRmation in Europe http://inspire-geoportal.ec.europa.eu/ Nacional - IDEE (Infraestructura de Datos Espaciales de Espa\u00f1a) http://idee.es/ Regional - IDEC (Infraestructura de Dades Espacials de Catalunya) http://www.ide.cat Local - Barcelona http://w133.bcn.cat/geoportalbcn/GeoPortal.aspx?lang=es","title":"Niveles de desarrollo de una IDE"},{"location":"1_introduccion_a_las_ides/#idec","text":"La IDEC (Infraestructura de Dades Espacials de Catalunya) es una iniciativa creada el a\u00f1o 2002 para desarrollar y mantener una Infraestructura de Datos Espaciales (IDE) en el territorio de Catalunya. Esta infraestructura pretende facilitar y mejorar el acceso a la informaci\u00f3n y los servicios geogr\u00e1ficos disponibles, poniendo al alcance de los usuarios herramientas para buscar, descubrir, consultar y descargar estos recursos mediante la web, para utilizarlos y explotarlos posteriormente. El proyecto se hace posible gracias a la participaci\u00f3n activa y colaborativa de los diferentes tipos de actores involucrados: los productores y/o proveedores de informaci\u00f3n geogr\u00e1fica (o espacial) y los propios usuarios.","title":"IDEC"},{"location":"1_introduccion_a_las_ides/#idee","text":"La IDEE (Infraestructura de Datos Espaciales de Espa\u00f1a) tiene como objetivo integrar a trav\u00e9s de Internet los datos, metadatos, servicios e informaci\u00f3n de tipo geogr\u00e1fico que se producen en Espa\u00f1a, a nivel estatal, auton\u00f3mico y local, cumpliendo una serie de condiciones de interoperabilidad (normas, protocolos, especificaciones) y conforme a sus respectivos marcos legales. El fruto de este trabajo es el proyecto IDEE. La IDEE arranc\u00f3 en 2002 cuando la Comisi\u00f3n Permanente del Consejo Superior Geogr\u00e1fico aprob\u00f3 el 10 abril la puesta en marcha de una Infraestructura Nacional de Datos Espaciales. IDEE es el resultado de la integraci\u00f3n, en primer lugar, de todas las IDE establecidas por los productores oficiales de datos a nivel tanto estatal como auton\u00f3mico y local, y en segundo lugar, de todo tipo de infraestructuras sectoriales y privadas. En cada C.C.A.A y organismo de la Administraci\u00f3n General del Estado (AGE) hay un representante, responsable de la implantaci\u00f3n de la IDE en su C.C.A.A y en el organismo de la AGE.","title":"IDEE"},{"location":"1_introduccion_a_las_ides/#marco-legal","text":"En Espa\u00f1a la LISIGE se aplica a todos los datos geogr\u00e1ficos que cumplan las siguientes condiciones Se refieran a una zona geogr\u00e1fica del territorio nacional, el mar territorial, la zona contigua, la plataforma continental y la zona exclusiva econ\u00f3mica exclusiva, generada o bajo responsabilidad de las Administraciones p\u00fablicas y sobre la que el Estado tenga jurisdicci\u00f3n Est\u00e9n en formato electr\u00f3nico Su producci\u00f3n y mantenimiento sea competencia de una Administraci\u00f3n u organismo del sector p\u00fablico Se refieran a Informaci\u00f3n Geogr\u00e1fica de Referencia o a Datos Tem\u00e1ticos Fundamentales o a Datos Tem\u00e1ticos Generales existentes, salvaguardando en este caso los intereses prioritarios de la defensa nacional","title":"Marco legal"},{"location":"1_introduccion_a_las_ides/#inspire","text":"INSPIRE (INfrastructure for SPatial InfoRmation in Europe) tiene por objetivo hacer disponible una informaci\u00f3n geogr\u00e1fica de calidad, armonizada y relevante para apoyar la formulaci\u00f3n, la implementaci\u00f3n, la monitorizaci\u00f3n y la evaluaci\u00f3n de las pol\u00edticas comunitarias con un impacto o dimensi\u00f3n territorial. INSPIRE es una iniciativa legal de la UE que dirigir\u00e1 protocolos y est\u00e1ndares, aspectos de coordinaci\u00f3n y organizaci\u00f3n, pol\u00edticas de datos incluyendo el acceso a los datos y la creaci\u00f3n y el mantenimiento de la informaci\u00f3n espacial. El 17 de noviembre de 2003, el Parlamento Europeo aprob\u00f3 la Directiva 2003/98 CE, en lo referente a la reutilizaci\u00f3n de la informaci\u00f3n del sector p\u00fablico. Su finalidad es fijar un marco legal que armonice el uso y la explotaci\u00f3n de la informaci\u00f3n del sector p\u00fablico (condiciones de reutilizaci\u00f3n, formatos disponibles, principios de tarificaci\u00f3n, transparencia, etc.), fomentando as\u00ed un mercado interior entre todos los estados miembros. La nueva directiva se dirige claramente a facilitar informaci\u00f3n desde las Entidades P\u00fablicas hacia el sector privado, que puede darle un amplio valor a\u00f1adido a. De manera especial favorecer\u00e1 la difusi\u00f3n de informaci\u00f3n geogr\u00e1fica, dado que las administraciones p\u00fablicas son el principal generador de este tipo de informaci\u00f3n. Lo que puede reforzar iniciativas IDE, entre muchas de otras. Para asegurar que las infraestructuras de datos espaciales de los Estados miembros sean compatibles e interoperables en un contexto comunitario y transfronterizo, la Directiva exige que se adopten Normas de Ejecuci\u00f3n comunes Implementing Rules) espec\u00edficas para las siguientes \u00e1reas metadatos, conjuntos de datos, servicios de red, servicios de datos espaciales, datos y servicios de uso compartido y seguimiento e informes Estas normas son de obligado cumplimiento en cada uno de los pa\u00edses de la Uni\u00f3n La Directiva INSPIRE se aplica en diferentes etapas hasta el 2021 que deber\u00e1 tener aplicaci\u00f3n plena Es el primer paso de una amplia iniciativa multisectorial, que inicialmente se centrar\u00e1 en la informaci\u00f3n espacial necesaria para las pol\u00edticas medio ambientales y que estar\u00e1 abierta a las necesidades de otras \u00e1reas pol\u00edticas como la agricultura y el transporte. La situaci\u00f3n general respecto a la informaci\u00f3n espacial en Europa es de fragmentaci\u00f3n de datos y fuentes. Hay lagunas en la disponibilidad de los datos, carencia de harmonizaci\u00f3n entre conjuntos de datos en las diferentes escalas y sistemas de referencia y duplicaci\u00f3n de la informaci\u00f3n. Estos problemas hacen dif\u00edcil la identificaci\u00f3n, el acceso y el uso de los datos disponibles. Afortunadamente, est\u00e1 creciendo la conciencia sobre la necesidad de una informaci\u00f3n georeferenciada de calidad para entender mejor las relaciones humanas con su entorno. La iniciativa tiene la intenci\u00f3n de crear una infraestructura europea de datos espaciales que d\u00e9 servicios de informaci\u00f3n espacial integrada a los usuarios. Estos servicios tendr\u00e1n que permitir a los usuarios identificar y acceder a la informaci\u00f3n geogr\u00e1fica de muy variadas fuentes, garantizando la interoperatividad. Los posibles servicios son la visualizaci\u00f3n de capas de informaci\u00f3n, la superposici\u00f3n de informaci\u00f3n procedente de diferentes fuentes, el an\u00e1lisis espacial y temporal, etc.","title":"INSPIRE"},{"location":"1_introduccion_a_las_ides/#principios-de-inspire","text":"Los datos tienen que recogerse una sola vez y conservarse en el nivel donde resulten m\u00e1s eficaces. Tiene que ser posible combinar, sin problemas de continuidad, la informaci\u00f3n geogr\u00e1fica procedente de diferentes fuentes europeas y ponerla al alcance de los usuarios y aplicaciones. La informaci\u00f3n recogida a un nivel tiene que poder ser compartida a todos los niveles, la informaci\u00f3n a gran escala para investigaciones detalladas, y la de peque\u00f1a escala para finalidades estrat\u00e9gicas. La informaci\u00f3n geogr\u00e1fica necesaria a todos los niveles tiene que ser abundante sin limitar su uso extensivo Tiene que ser sencillo descubrir qu\u00e9 informaci\u00f3n geogr\u00e1fica est\u00e1 disponible, si cubre las necesidades para un uso determinado y bajo qu\u00e9 condiciones se puede adquirir y utilizar Los datos geogr\u00e1ficos tienen que ser f\u00e1ciles de entender y de interpretar porque tienen que estar adecuadamente documentados","title":"Principios de INSPIRE"},{"location":"1_introduccion_a_las_ides/#temas-inspire","text":"","title":"Temas INSPIRE"},{"location":"1_introduccion_a_las_ides/#annex-i","text":"Coordinate reference systems Geographical grid systems Geographical names Administrative units Addresses Cadastral parcels Transport networks Hydrography Protected sites","title":"Annex I"},{"location":"1_introduccion_a_las_ides/#annex-ii","text":"Elevation Land cover Orthoimagery Geology","title":"Annex II"},{"location":"1_introduccion_a_las_ides/#annex-iii","text":"Statistical units Buildings Soil Land use Human health and safety Utility and governmental services Environmental monitoring Facilities Production and industrial facilities Agricultural and aquaculture facilities Population distribution and demography Area management / restriction / regulation zones & reporting units Natural risk zones Atmospheric conditions Meteorological geographical features Oceanographic geographical features Sea regions Bio-geographical regions Habitats and biotopes Species distribution Energy Resources Mineral Resources","title":"Annex III"},{"location":"1_introduccion_a_las_ides/#otras-ides","text":"","title":"Otras IDES"},{"location":"1_introduccion_a_las_ides/#gsdi-global-spatial-data-infrastructure","text":"Convertida en asociaci\u00f3n el a\u00f1o 2004, esta iniciativa empez\u00f3 a mediados de los 90 con el objetivo de fomentar la captura, el procesamiento, la integraci\u00f3n y la compartici\u00f3n de informaci\u00f3n y datos espaciales, utilizando est\u00e1ndares comunes y t\u00e9cnicas y sistemas interoperables, accesibles v\u00eda web. La GSDI organiza conferencias de forma regular. La primera se celebr\u00f3 el a\u00f1o 95 en Bonn, d\u00f3nde s\u00f3lo fueron invitados un peque\u00f1o n\u00famero de asistentes. En la conferencia del a\u00f1o 97, definieron la GSDI c\u00f3mo: \u201c...las pol\u00edticas, misiones organizativas, datos, tecnolog\u00edas, est\u00e1ndares, mecanismos de distribuci\u00f3n y recursos financieros y humanos para asegurar que no se impida lograr los objetivos, a aquellos que trabajan a escala global y local\u201d. Tiene por objetivo fomentar la captura, el procesamiento, la integraci\u00f3n, el almacenamiento y el intercambio de datos e informaci\u00f3n espacial utilizando est\u00e1ndares comunes y t\u00e9cnicas y sistemas interoperables v\u00eda web. Para lograrlo, es necesario poner un especial \u00e9nfasis en los m\u00e9todos de difusi\u00f3n, educaci\u00f3n, recursos, pol\u00edticas y aspectos legales relacionados con su desarrollo.","title":"GSDI (Global Spatial Data Infrastructure)"},{"location":"1_introduccion_a_las_ides/#ejemplos-de-otras-ides","text":"","title":"Ejemplos de otras IDES"},{"location":"1_introduccion_a_las_ides/#internacional","text":"Geoportal ONU","title":"Internacional"},{"location":"1_introduccion_a_las_ides/#nacional","text":"IGN France Estados Unidos Chile","title":"Nacional"},{"location":"1_introduccion_a_las_ides/#regional","text":"IDE Canarias IDE Andaluc\u00eda","title":"Regional"},{"location":"1_introduccion_a_las_ides/#local","text":"C\u00e1ceres","title":"Local"},{"location":"1_introduccion_a_las_ides/#referencias","text":"https://github.com/volaya/libro-sig/releases/download/v2.0/Libro_SIG.pdf \u21a9 https://www.miteco.gob.es/es/cartografia-y-sig/ide/presentacion/que-es-ide.aspx \u21a9","title":"Referencias"},{"location":"2_estandares_OCG/","text":"Est\u00e1ndares OCG Qu\u00e9 es OGC? El OGC (Open Geospatial Consortium fu\u00e9 creada en 1994 y est\u00e1 formada por m\u00e1s de 500 empresas, agencias gubernamentales y universidades. Es una organizaci\u00f3n internacional sin \u00e1nimo de lucro comprometida con la elaboraci\u00f3n de est\u00e1ndares abiertos e interoperables de calidad para la comunidad geoespacial global. Estos est\u00e1ndares se elaboran a trav\u00e9s de un proceso de consenso y est\u00e1n disponibles de forma gratuita para que cualquier persona pueda utilizarlos para mejorar el intercambio de los datos geoespaciales del mundo. Estas especificaciones tienen como objetivo, fomentar la interoperabilidad geoespacial. El \u00e9xito de estas especificaciones radica en el hecho de que son impulsadas y creadas por las mismas empresas, que despu\u00e9s las implementan en sus productos comerciales. Interoperabilidad Se puede definir la interoperabilidad como la habilidad de dos o m\u00e1s sistemas para intercambiar informaci\u00f3n y poderla utilizar, sin ning\u00fan esfuerzo por parte del usuario. Las modalidades de interoperatividad dependen de los agentes que interaccionan. Dicho de otra manera, los datos producidos en un entorno operativo tienen que poder ser le\u00eddos e interpretados por otro entorno sin que el usuario tenga que hacer una conversi\u00f3n de formatos. La interoperabilidad permite: Acceder a m\u00e1s y mejor informaci\u00f3n (topogr\u00e1ficos, ortoim\u00e1genes, callejeros, catastro, medio ambiente...), sin tener que disponer de un software espec\u00edfico o directamente desde el navegador. Esto permite que el usuario pueda acceder a cartograf\u00eda de varias fuentes, con arquitecturas diferentes, de una forma f\u00e1cil y transparente. Facilita el acceso a geoservicios. Est\u00e1ndares OGC Un est\u00e1ndar es un modelo, un patr\u00f3n que tiene como finalidad la fijaci\u00f3n de unas normas comunes para garantizar la homogeneidad en el proceso de producci\u00f3n. Pero para que tenga \u00e9xito tiene que tener un uso mayoritario. Est\u00e1ndares Para conseguir que, tanto la documentaci\u00f3n de los datos como la creaci\u00f3n de servicios sea comprensible y accesible para todo el mundo, es decir, para hacer que todos \u201chablemos el mismo idioma\u201d, se han dise\u00f1ado est\u00e1ndares de metadatos y de servicios que pretenden poner en com\u00fan los puntos de vista de los diferentes productores. Por lo tanto, la estandarizaci\u00f3n consiste en hacer que, tanto la documentaci\u00f3n de datos como la creaci\u00f3n de geoservicios, as\u00ed como su acceso, se hagan conforme a unas norma previamente establecidas. Los est\u00e1ndares de la OGC son documentos de car\u00e1cter t\u00e9cnico d\u00f3nde se describen las interfaces de comunicaci\u00f3n entre servidores y la forma de implementarlos. En estas especificaciones no se menciona ni la arquitectura, plataforma o lenguajes de programaci\u00f3n a utilizar. Los documentos, antes de ser consideradas como una OpenGIS Implementation Specification, son elaborados y probados por diferentes grupos de trabajo dentro de OGC y finalmente sometidas a votaci\u00f3n. Los servicios de cartograf\u00eda online o web de OGC (OWS) son est\u00e1ndares de OGC creados para su uso en aplicaciones de la World Wide Web (WWW). Estos permiten formular petiones al servidor para: enviar preguntas, obtener datos vectoriales o r\u00e1ster, hacer geoprocesos, etc. Todos los est\u00e1ndares creados por OGC se pueden consultar en https://www.ogc.org/docs/is Evoluci\u00f3n de servicios OWS WMS La intenci\u00f3n de WMS (Web Map Service) es la de permitir la superposici\u00f3n visual de informaci\u00f3n geogr\u00e1fica compleja y distribuida en diferentes servidores. Un cliente puede hacer peticiones a otros servidores tambi\u00e9n basados en esta especificaci\u00f3n para descubrir informaci\u00f3n geogr\u00e1fica deseada. Una vez encontrada el cliente puede recurrir a ella de forma simult\u00e1nea y puede visualizar diferentes datos geogr\u00e1ficos de diferentes servidores en un mismo entorno. Cada petici\u00f3n est\u00e1 compuesta por unos par\u00e1metros concretos definidos por la especificaci\u00f3n WMS y que es entendida por todos los servidores de mapas que cumplen con la especificaci\u00f3n. Por lo tanto, cuando se dice que un Servidor de Mapas es est\u00e1ndar y cumple con WMS, significa que es capaz de dar respuesta a estas peticiones. El est\u00e1ndar WMS proporciona una interfaz HTTP simple para solicitar im\u00e1genes de mapas georegistrados desde una o m\u00e1s bases de datos geoespaciales distribuidas. Tipos de peticiones WMS GetCapabilities Nos permite descubrir cuales son las capacidades del servidor. Como respuesta va a obtener un archivo en formato xml d\u00f3nde podremos saber cuales son las caracter\u00edsticas del servicio, las versiones de WMS soportadas por el servidor, las operaciones que soporta, cual es su sistema de referencia, sus coordenadas, que formato de imagen soporta y metadatos de las capas de informaci\u00f3n que contiene. Par\u00e1metros del GetCapabilities Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetCapabilities ) LANGUAGE Opcional Se obtiene el fichero de salida en el idioma solicidado FORMAT Opcional Formato de salida del metadato del servicio. (Por defecto text/xml) Ejemplos: http://www.ign.es/wms-inspire/ign-base?VERSION=1.3.0&REQUEST=GetCapabilities&SERVICE=WMS http://geoserveis.icc.cat/icc_bt5m/wms/service?REQUEST=GetCapabilities&SERVICE=WMS Aspectos pr\u00e1cticos Tama\u00f1o m\u00e1ximo de la im\u00e1gen Si se pide una imagen mayor que el tama\u00f1o m\u00e1ximo permitodo retornar\u00e1 un error <Service> <Name> icc_bt5m </Name> <Title> ICC - Base topogr\u00e0fica de Catalunya 1:5 000 (BT-5M) - Capes WMS 96dpi (p\u00edxel 0,26458333 mm) </Title> ... <MaxWidth> 2048 </MaxWidth> <MaxHeight> 2048 </MaxHeight> </Service> OnlineResource En algunos software de escritorio utiliza esta url para hacer las peticiones de las operaciones GetMap. <GetMap> <Format> image/jp2;subtype=\"gmljp2\" </Format> <Format> image/gif </Format> <Format> image/png </Format> <Format> image/bmp </Format> <Format> image/jpeg </Format> <Format> image/tiff </Format> <DCPType> <HTTP> <Get> <OnlineResource xmlns:xlink= \"http://www.w3.org/1999/xlink\" xlink:href= \"http://shagrat.icc.cat/lizardtech/iserv/ows\" xlink:type= \"simple\" /> </Get> </HTTP> </DCPType> </GetMap> Layer El atributo queryable indica si la capa es consultable (1 = consultable, 0 = no consultable) Name es indentificador de la capa. Es el valor que se debe usar en el par\u00e1metro LAYERS de las peticiones GetMap Title es nombre descriptivo de la capa LegendURL hace referencia a una url de una imagen externa que contiene la leyenda de la capa Min y Max(ScaleDenominator) factor de escala. Limita la visualizaci\u00f3n de la capa a estas escalas. Si se pide una capa fuera de esa escala retorna en blanco. <Layer queryable= \"1\" > <Name> 02_ALTI_PA </Name> <Title> [BT5M] (02) (x) ALTIMETRIA: talussos, marges (\u00e0rees) </Title> <Abstract> 02_ALTI_PA </Abstract> <CRS> EPSG:25831 </CRS> <CRS> EPSG:4326 </CRS> <BoundingBox CRS= \"EPSG:25831\" minx= \"254904.96\" miny= \"4484796.89\" maxx= \"530907.30\" maxy= \"4749795.10\" /> ... <Style> ... <LegendURL width= \"328\" height= \"64\" > <Format> image/png </Format> <OnlineResource xmlns:xlink= \"http://www.w3.org/1999/xlink\" xlink:href= \"http://geoserveis.icc.cat/icc_bt5m/wms/service?request=GetLegendGraphic%26version=1.3.0%26format=image/png%26layer=02_ALTI_PA\" xlink:type= \"simple\" /> </LegendURL> </Style> <MinScaleDenominator> 472.470238 </MinScaleDenominator> <MaxScaleDenominator> 7087.053571 </MaxScaleDenominator> </Layer> GetFeatureInfo Formatos de salida de la consulta <GetFeatureInfo> <Format> application/vnd.esri.wms_raw_xml </Format> <Format> application/vnd.esri.wms_featureinfo_xml </Format> <Format> application/vnd.ogc.wms_xml </Format> <Format> text/xml </Format> <Format> text/html </Format> <Format> text/plain </Format> <DCPType> <HTTP> <Get> <OnlineResource xmlns:xlink= \"http://www.w3.org/1999/xlink\" xlink:type= \"simple\" xlink:href= \"http://geoserveis.icc.cat/icc_bt5m/wms/service?\" /> </Get> </HTTP> </DCPType> </GetFeatureInfo> GetMap Petici\u00f3n GetMap devolver\u00e1 un mapa en formato imagen, ya sea un PNG, JPEG, GIF, etc. Par\u00e1metros del GetMap Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetMap ) LAYERS Obligatorio Lista de nombres de las capas separadas por coma FORMAT Obligatorio Formato de salida de la imagen. (image/png, image/jpeg, ...) STYLES Obligatorio Lista de estilos separados por coma. Si no hay estilo se puede dejar en blanco SRS o CRS Obligatorio C\u00f3digo ESPG del sistema de referencia BBOX Obligatorio Caja de coordenadas del mapa (minx,miny,maxx,maxy) WIDTH Obligatorio N\u00famero p\u00edxeles del ancho de la im\u00e1gen HEIGHT Obligatorio N\u00famero p\u00edxeles del alto de la im\u00e1gen TRANSPARENT Opcional Indica si el fondo del mapa debe ser transparente (true ,false) BGCOLOR Opcional Color de fondo para la imagen del mapa. El valor est\u00e1 en la formato RRGGBB hexadecimal SLD Opcional Una URL que hace referencia a un archivo XML StyledLayerDescriptor que controla el estilo de las capas de mapa EXCEPTIONS Opcional Formato excepciones Ejemplo: http://www.ign.es/wms-inspire/ign-base?SERVICE=WMS&REQUEST=GetMap&VERSION=1.3.0&LAYERS=IGNBaseTodo&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:4258&BBOX=26.4764705882353,-19,44.5235294117647,5&WIDTH=1020&HEIGHT=767 GetFeatureInfo Petici\u00f3n GetFeatureInfo sirve para mostrar los atributos de los objetos del mapa, vuelve la informaci\u00f3n en formato de tabla o XML. Si una capa est\u00e1 marcada como \u201cconsultable\u201d (queryable), se puede solicitar datos sobre una coordenada de la imagen del mapa. Par\u00e1metros del GetFeatureInfo Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetFeatureInfo ) LAYERS Obligatorio Lista de nombres de las capas separadas por coma FORMAT Obligatorio Formato de salida de la imagen. (image/png, image/jpeg, ...) STYLES Obligatorio Lista de estilos separados por coma. Si no hay estilo se puede dejar en blanco SRS o CRS Obligatorio C\u00f3digo ESPG del sistema de referencia BBOX Obligatorio Caja de coordenadas del mapa (minx,miny,maxx,maxy) WIDTH Obligatorio N\u00famero p\u00edxeles del ancho de la im\u00e1gen HEIGHT Obligatorio N\u00famero p\u00edxeles del alto de la im\u00e1gen QUERY_LAYERS Obligatorio Lista de nombres de las capas que se quieren consultar separadas por coma X o I Obligatorio Valor del p\u00edxel a consultar Y o J Obligatorio Valor del p\u00edxel a consultar INFO_FORMAT Opcional Formato de la respuesta (por defecto text/xml) FEATURE_COUNT Opcional N\u00famero m\u00e1ximo de elementos a devolver EXCEPTIONS Opcional Formato excepciones Ejemplo: http://geoserveis.icc.cat/icgc_bm5m/wms/service?REQUEST=GetFeatureInfo&SERVICE=WMS&VERSION=1.1.1&LAYERS=10_MUNICIPI_PC&QUERY_LAYERS=10_MUNICIPI_PC&INFO_FORMAT=text/html&STYLES=&SRS=EPSG:25831&BBOX=257904,4484796,680304,4907196&WIDTH=768&HEIGHT=768&X=295&Y=580 GetLegendGraphic Petici\u00f3n que devuelve una imagen de la imagen de la leyenda del mapa de una capa, proporcionando una gu\u00eda visual de los elementos del mapa. Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetLegendGraphic ) LAYER Obligatorio Nombre de la capa FORMAT Obligatorio Formato de salida de la imagen. (image/png, image/jpeg, ...) WIDTH Opcional N\u00famero p\u00edxeles del ancho de la im\u00e1gen HEIGHT Opcional N\u00famero p\u00edxeles del alto de la im\u00e1gen Ejemplo: http://wms.guifi.net/cgi-bin/mapserv?map=/home/guifi/maps.guifi.net/guifimaps/GMap.map&version=1.3.0&service=WMS&request=GetLegendGraphic&sld_version=1.1.0&layer=Nodes&format=image/png&STYLE=default Aspector pr\u00e1cticos WMS Principales diferencias entre las versiones 1.1.1 y 1.3.0 En la operaci\u00f3n GetMap, el par\u00e1metro SRS se llama CRS en 1.3.0 En la operaci\u00f3n GetFeatureInfo, los par\u00e1metros X e Y se llaman I y J en 1.3.0. En 1.1.1, los sistemas de coordenadas geogr\u00e1ficas especificados con el espacio de nombres EPSG se definen para tener un orden de ejes de longitud / latitud. En 1.3.0 el orden es la latitud / longitud. Por ejemplo, considere la solicitud WMS 1.1 utilizando el SRS WGS84 (EPSG: 4326): 1 server/wms?VERSION=1.1.1&REQUEST=GetMap&SRS=epsg:4326&BBOX=-180,-90,180,90&... La solicitud equivalente WMS 1.3.0 es: 1 server/wms?VERSION=1.3.0&REQUEST=GetMap&CRS=epsg:4326&BBOX=-90,-180,90,180&... Problemas comunes Tama\u00f1o de la imagen (pantallas grandes y/o de mucha resoluci\u00f3n) Capas no visibles por el control de escala Capas no consultables Formato de salida del GetFeatureInfo No est\u00e1n pensados para peticiones teseladas (velocidad) No tienen cach\u00e9. Las im\u00e1genes se generan al vuelo Lista restringida de SRS soportados En software de escritorio el onlineResource (QGis tiene la opci\u00f3n de ignorar el onlineResource ) Modificar el estilo (SLD poco soportado) SLD dif\u00edcil de entender y hacer WMTS WFS SLD SOS GML CSW Otros est\u00e1ndares OGC","title":"2. Est\u00e1ndares OCG"},{"location":"2_estandares_OCG/#estandares-ocg","text":"","title":"Est\u00e1ndares OCG"},{"location":"2_estandares_OCG/#que-es-ogc","text":"El OGC (Open Geospatial Consortium fu\u00e9 creada en 1994 y est\u00e1 formada por m\u00e1s de 500 empresas, agencias gubernamentales y universidades. Es una organizaci\u00f3n internacional sin \u00e1nimo de lucro comprometida con la elaboraci\u00f3n de est\u00e1ndares abiertos e interoperables de calidad para la comunidad geoespacial global. Estos est\u00e1ndares se elaboran a trav\u00e9s de un proceso de consenso y est\u00e1n disponibles de forma gratuita para que cualquier persona pueda utilizarlos para mejorar el intercambio de los datos geoespaciales del mundo. Estas especificaciones tienen como objetivo, fomentar la interoperabilidad geoespacial. El \u00e9xito de estas especificaciones radica en el hecho de que son impulsadas y creadas por las mismas empresas, que despu\u00e9s las implementan en sus productos comerciales.","title":"Qu\u00e9 es OGC?"},{"location":"2_estandares_OCG/#interoperabilidad","text":"Se puede definir la interoperabilidad como la habilidad de dos o m\u00e1s sistemas para intercambiar informaci\u00f3n y poderla utilizar, sin ning\u00fan esfuerzo por parte del usuario. Las modalidades de interoperatividad dependen de los agentes que interaccionan. Dicho de otra manera, los datos producidos en un entorno operativo tienen que poder ser le\u00eddos e interpretados por otro entorno sin que el usuario tenga que hacer una conversi\u00f3n de formatos. La interoperabilidad permite: Acceder a m\u00e1s y mejor informaci\u00f3n (topogr\u00e1ficos, ortoim\u00e1genes, callejeros, catastro, medio ambiente...), sin tener que disponer de un software espec\u00edfico o directamente desde el navegador. Esto permite que el usuario pueda acceder a cartograf\u00eda de varias fuentes, con arquitecturas diferentes, de una forma f\u00e1cil y transparente. Facilita el acceso a geoservicios.","title":"Interoperabilidad"},{"location":"2_estandares_OCG/#estandares-ogc","text":"Un est\u00e1ndar es un modelo, un patr\u00f3n que tiene como finalidad la fijaci\u00f3n de unas normas comunes para garantizar la homogeneidad en el proceso de producci\u00f3n. Pero para que tenga \u00e9xito tiene que tener un uso mayoritario. Est\u00e1ndares Para conseguir que, tanto la documentaci\u00f3n de los datos como la creaci\u00f3n de servicios sea comprensible y accesible para todo el mundo, es decir, para hacer que todos \u201chablemos el mismo idioma\u201d, se han dise\u00f1ado est\u00e1ndares de metadatos y de servicios que pretenden poner en com\u00fan los puntos de vista de los diferentes productores. Por lo tanto, la estandarizaci\u00f3n consiste en hacer que, tanto la documentaci\u00f3n de datos como la creaci\u00f3n de geoservicios, as\u00ed como su acceso, se hagan conforme a unas norma previamente establecidas. Los est\u00e1ndares de la OGC son documentos de car\u00e1cter t\u00e9cnico d\u00f3nde se describen las interfaces de comunicaci\u00f3n entre servidores y la forma de implementarlos. En estas especificaciones no se menciona ni la arquitectura, plataforma o lenguajes de programaci\u00f3n a utilizar. Los documentos, antes de ser consideradas como una OpenGIS Implementation Specification, son elaborados y probados por diferentes grupos de trabajo dentro de OGC y finalmente sometidas a votaci\u00f3n. Los servicios de cartograf\u00eda online o web de OGC (OWS) son est\u00e1ndares de OGC creados para su uso en aplicaciones de la World Wide Web (WWW). Estos permiten formular petiones al servidor para: enviar preguntas, obtener datos vectoriales o r\u00e1ster, hacer geoprocesos, etc. Todos los est\u00e1ndares creados por OGC se pueden consultar en https://www.ogc.org/docs/is Evoluci\u00f3n de servicios OWS","title":"Est\u00e1ndares OGC"},{"location":"2_estandares_OCG/#wms","text":"La intenci\u00f3n de WMS (Web Map Service) es la de permitir la superposici\u00f3n visual de informaci\u00f3n geogr\u00e1fica compleja y distribuida en diferentes servidores. Un cliente puede hacer peticiones a otros servidores tambi\u00e9n basados en esta especificaci\u00f3n para descubrir informaci\u00f3n geogr\u00e1fica deseada. Una vez encontrada el cliente puede recurrir a ella de forma simult\u00e1nea y puede visualizar diferentes datos geogr\u00e1ficos de diferentes servidores en un mismo entorno. Cada petici\u00f3n est\u00e1 compuesta por unos par\u00e1metros concretos definidos por la especificaci\u00f3n WMS y que es entendida por todos los servidores de mapas que cumplen con la especificaci\u00f3n. Por lo tanto, cuando se dice que un Servidor de Mapas es est\u00e1ndar y cumple con WMS, significa que es capaz de dar respuesta a estas peticiones. El est\u00e1ndar WMS proporciona una interfaz HTTP simple para solicitar im\u00e1genes de mapas georegistrados desde una o m\u00e1s bases de datos geoespaciales distribuidas.","title":"WMS"},{"location":"2_estandares_OCG/#tipos-de-peticiones-wms","text":"","title":"Tipos de peticiones WMS"},{"location":"2_estandares_OCG/#getcapabilities","text":"Nos permite descubrir cuales son las capacidades del servidor. Como respuesta va a obtener un archivo en formato xml d\u00f3nde podremos saber cuales son las caracter\u00edsticas del servicio, las versiones de WMS soportadas por el servidor, las operaciones que soporta, cual es su sistema de referencia, sus coordenadas, que formato de imagen soporta y metadatos de las capas de informaci\u00f3n que contiene.","title":"GetCapabilities"},{"location":"2_estandares_OCG/#parametros-del-getcapabilities","text":"Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetCapabilities ) LANGUAGE Opcional Se obtiene el fichero de salida en el idioma solicidado FORMAT Opcional Formato de salida del metadato del servicio. (Por defecto text/xml) Ejemplos: http://www.ign.es/wms-inspire/ign-base?VERSION=1.3.0&REQUEST=GetCapabilities&SERVICE=WMS http://geoserveis.icc.cat/icc_bt5m/wms/service?REQUEST=GetCapabilities&SERVICE=WMS","title":"Par\u00e1metros del GetCapabilities"},{"location":"2_estandares_OCG/#aspectos-practicos","text":"","title":"Aspectos pr\u00e1cticos"},{"location":"2_estandares_OCG/#tamano-maximo-de-la-imagen","text":"Si se pide una imagen mayor que el tama\u00f1o m\u00e1ximo permitodo retornar\u00e1 un error <Service> <Name> icc_bt5m </Name> <Title> ICC - Base topogr\u00e0fica de Catalunya 1:5 000 (BT-5M) - Capes WMS 96dpi (p\u00edxel 0,26458333 mm) </Title> ... <MaxWidth> 2048 </MaxWidth> <MaxHeight> 2048 </MaxHeight> </Service>","title":"Tama\u00f1o m\u00e1ximo de la im\u00e1gen"},{"location":"2_estandares_OCG/#onlineresource","text":"En algunos software de escritorio utiliza esta url para hacer las peticiones de las operaciones GetMap. <GetMap> <Format> image/jp2;subtype=\"gmljp2\" </Format> <Format> image/gif </Format> <Format> image/png </Format> <Format> image/bmp </Format> <Format> image/jpeg </Format> <Format> image/tiff </Format> <DCPType> <HTTP> <Get> <OnlineResource xmlns:xlink= \"http://www.w3.org/1999/xlink\" xlink:href= \"http://shagrat.icc.cat/lizardtech/iserv/ows\" xlink:type= \"simple\" /> </Get> </HTTP> </DCPType> </GetMap>","title":"OnlineResource"},{"location":"2_estandares_OCG/#layer","text":"El atributo queryable indica si la capa es consultable (1 = consultable, 0 = no consultable) Name es indentificador de la capa. Es el valor que se debe usar en el par\u00e1metro LAYERS de las peticiones GetMap Title es nombre descriptivo de la capa LegendURL hace referencia a una url de una imagen externa que contiene la leyenda de la capa Min y Max(ScaleDenominator) factor de escala. Limita la visualizaci\u00f3n de la capa a estas escalas. Si se pide una capa fuera de esa escala retorna en blanco. <Layer queryable= \"1\" > <Name> 02_ALTI_PA </Name> <Title> [BT5M] (02) (x) ALTIMETRIA: talussos, marges (\u00e0rees) </Title> <Abstract> 02_ALTI_PA </Abstract> <CRS> EPSG:25831 </CRS> <CRS> EPSG:4326 </CRS> <BoundingBox CRS= \"EPSG:25831\" minx= \"254904.96\" miny= \"4484796.89\" maxx= \"530907.30\" maxy= \"4749795.10\" /> ... <Style> ... <LegendURL width= \"328\" height= \"64\" > <Format> image/png </Format> <OnlineResource xmlns:xlink= \"http://www.w3.org/1999/xlink\" xlink:href= \"http://geoserveis.icc.cat/icc_bt5m/wms/service?request=GetLegendGraphic%26version=1.3.0%26format=image/png%26layer=02_ALTI_PA\" xlink:type= \"simple\" /> </LegendURL> </Style> <MinScaleDenominator> 472.470238 </MinScaleDenominator> <MaxScaleDenominator> 7087.053571 </MaxScaleDenominator> </Layer>","title":"Layer"},{"location":"2_estandares_OCG/#getfeatureinfo","text":"Formatos de salida de la consulta <GetFeatureInfo> <Format> application/vnd.esri.wms_raw_xml </Format> <Format> application/vnd.esri.wms_featureinfo_xml </Format> <Format> application/vnd.ogc.wms_xml </Format> <Format> text/xml </Format> <Format> text/html </Format> <Format> text/plain </Format> <DCPType> <HTTP> <Get> <OnlineResource xmlns:xlink= \"http://www.w3.org/1999/xlink\" xlink:type= \"simple\" xlink:href= \"http://geoserveis.icc.cat/icc_bt5m/wms/service?\" /> </Get> </HTTP> </DCPType> </GetFeatureInfo>","title":"GetFeatureInfo"},{"location":"2_estandares_OCG/#getmap","text":"Petici\u00f3n GetMap devolver\u00e1 un mapa en formato imagen, ya sea un PNG, JPEG, GIF, etc.","title":"GetMap"},{"location":"2_estandares_OCG/#parametros-del-getmap","text":"Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetMap ) LAYERS Obligatorio Lista de nombres de las capas separadas por coma FORMAT Obligatorio Formato de salida de la imagen. (image/png, image/jpeg, ...) STYLES Obligatorio Lista de estilos separados por coma. Si no hay estilo se puede dejar en blanco SRS o CRS Obligatorio C\u00f3digo ESPG del sistema de referencia BBOX Obligatorio Caja de coordenadas del mapa (minx,miny,maxx,maxy) WIDTH Obligatorio N\u00famero p\u00edxeles del ancho de la im\u00e1gen HEIGHT Obligatorio N\u00famero p\u00edxeles del alto de la im\u00e1gen TRANSPARENT Opcional Indica si el fondo del mapa debe ser transparente (true ,false) BGCOLOR Opcional Color de fondo para la imagen del mapa. El valor est\u00e1 en la formato RRGGBB hexadecimal SLD Opcional Una URL que hace referencia a un archivo XML StyledLayerDescriptor que controla el estilo de las capas de mapa EXCEPTIONS Opcional Formato excepciones Ejemplo: http://www.ign.es/wms-inspire/ign-base?SERVICE=WMS&REQUEST=GetMap&VERSION=1.3.0&LAYERS=IGNBaseTodo&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:4258&BBOX=26.4764705882353,-19,44.5235294117647,5&WIDTH=1020&HEIGHT=767","title":"Par\u00e1metros del GetMap"},{"location":"2_estandares_OCG/#getfeatureinfo_1","text":"Petici\u00f3n GetFeatureInfo sirve para mostrar los atributos de los objetos del mapa, vuelve la informaci\u00f3n en formato de tabla o XML. Si una capa est\u00e1 marcada como \u201cconsultable\u201d (queryable), se puede solicitar datos sobre una coordenada de la imagen del mapa.","title":"GetFeatureInfo"},{"location":"2_estandares_OCG/#parametros-del-getfeatureinfo","text":"Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetFeatureInfo ) LAYERS Obligatorio Lista de nombres de las capas separadas por coma FORMAT Obligatorio Formato de salida de la imagen. (image/png, image/jpeg, ...) STYLES Obligatorio Lista de estilos separados por coma. Si no hay estilo se puede dejar en blanco SRS o CRS Obligatorio C\u00f3digo ESPG del sistema de referencia BBOX Obligatorio Caja de coordenadas del mapa (minx,miny,maxx,maxy) WIDTH Obligatorio N\u00famero p\u00edxeles del ancho de la im\u00e1gen HEIGHT Obligatorio N\u00famero p\u00edxeles del alto de la im\u00e1gen QUERY_LAYERS Obligatorio Lista de nombres de las capas que se quieren consultar separadas por coma X o I Obligatorio Valor del p\u00edxel a consultar Y o J Obligatorio Valor del p\u00edxel a consultar INFO_FORMAT Opcional Formato de la respuesta (por defecto text/xml) FEATURE_COUNT Opcional N\u00famero m\u00e1ximo de elementos a devolver EXCEPTIONS Opcional Formato excepciones Ejemplo: http://geoserveis.icc.cat/icgc_bm5m/wms/service?REQUEST=GetFeatureInfo&SERVICE=WMS&VERSION=1.1.1&LAYERS=10_MUNICIPI_PC&QUERY_LAYERS=10_MUNICIPI_PC&INFO_FORMAT=text/html&STYLES=&SRS=EPSG:25831&BBOX=257904,4484796,680304,4907196&WIDTH=768&HEIGHT=768&X=295&Y=580","title":"Par\u00e1metros del GetFeatureInfo"},{"location":"2_estandares_OCG/#getlegendgraphic","text":"Petici\u00f3n que devuelve una imagen de la imagen de la leyenda del mapa de una capa, proporcionando una gu\u00eda visual de los elementos del mapa. Par\u00e1metro Obligatoriedad Descripci\u00f3n VERSION Obligatorio Versi\u00f3n de la especificaci\u00f3n OGC (1.0.0, 1.1.0, 1.1.1, 1.3.0) SERVICE Obligatorio Tipo de servicio al que va dirigida la petici\u00f3n ( WMS ) REQUEST Obligatorio Nombre de la operaci\u00f3n ( GetLegendGraphic ) LAYER Obligatorio Nombre de la capa FORMAT Obligatorio Formato de salida de la imagen. (image/png, image/jpeg, ...) WIDTH Opcional N\u00famero p\u00edxeles del ancho de la im\u00e1gen HEIGHT Opcional N\u00famero p\u00edxeles del alto de la im\u00e1gen Ejemplo: http://wms.guifi.net/cgi-bin/mapserv?map=/home/guifi/maps.guifi.net/guifimaps/GMap.map&version=1.3.0&service=WMS&request=GetLegendGraphic&sld_version=1.1.0&layer=Nodes&format=image/png&STYLE=default","title":"GetLegendGraphic"},{"location":"2_estandares_OCG/#aspector-practicos-wms","text":"","title":"Aspector pr\u00e1cticos WMS"},{"location":"2_estandares_OCG/#principales-diferencias-entre-las-versiones-111-y-130","text":"En la operaci\u00f3n GetMap, el par\u00e1metro SRS se llama CRS en 1.3.0 En la operaci\u00f3n GetFeatureInfo, los par\u00e1metros X e Y se llaman I y J en 1.3.0. En 1.1.1, los sistemas de coordenadas geogr\u00e1ficas especificados con el espacio de nombres EPSG se definen para tener un orden de ejes de longitud / latitud. En 1.3.0 el orden es la latitud / longitud. Por ejemplo, considere la solicitud WMS 1.1 utilizando el SRS WGS84 (EPSG: 4326): 1 server/wms?VERSION=1.1.1&REQUEST=GetMap&SRS=epsg:4326&BBOX=-180,-90,180,90&... La solicitud equivalente WMS 1.3.0 es: 1 server/wms?VERSION=1.3.0&REQUEST=GetMap&CRS=epsg:4326&BBOX=-90,-180,90,180&...","title":"Principales diferencias entre las versiones 1.1.1 y 1.3.0"},{"location":"2_estandares_OCG/#problemas-comunes","text":"Tama\u00f1o de la imagen (pantallas grandes y/o de mucha resoluci\u00f3n) Capas no visibles por el control de escala Capas no consultables Formato de salida del GetFeatureInfo No est\u00e1n pensados para peticiones teseladas (velocidad) No tienen cach\u00e9. Las im\u00e1genes se generan al vuelo Lista restringida de SRS soportados En software de escritorio el onlineResource (QGis tiene la opci\u00f3n de ignorar el onlineResource ) Modificar el estilo (SLD poco soportado) SLD dif\u00edcil de entender y hacer","title":"Problemas comunes"},{"location":"2_estandares_OCG/#wmts","text":"","title":"WMTS"},{"location":"2_estandares_OCG/#wfs","text":"","title":"WFS"},{"location":"2_estandares_OCG/#sld","text":"","title":"SLD"},{"location":"2_estandares_OCG/#sos","text":"","title":"SOS"},{"location":"2_estandares_OCG/#gml","text":"","title":"GML"},{"location":"2_estandares_OCG/#csw","text":"","title":"CSW"},{"location":"2_estandares_OCG/#otros-estandares-ogc","text":"","title":"Otros est\u00e1ndares OGC"},{"location":"3_conceptos_vector_tiles/","text":"Conceptos Vector Tiles Vector Tiles es un formato para almacenar datos geogr\u00e1ficos en formato binario (Google Protobuf) y pensados para la visualizaci\u00f3n en navegadores web modernos que soporten webGL. Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (XYZ,WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen. Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos. Contexto En 2005 GoogleMaps introdujo una \"nueva\" forma de mostrar datos geogr\u00e1ficos por la web, pregenerando el mapa por niveles de zoom y tiles (teselas) de 256x256 pixeles. Tambi\u00e9n cre\u00f3 una nueva proyecci\u00f3n basada en mercator, llamada pseude-mercator o web mercator , cuyo c\u00f3digo EPSG es 3857 Despu\u00e9s de GoogleMaps, otros proveedores o plataformas c\u00f3mo OpenStreetMap siguen esta misma forma de organizar la geoinformaci\u00f3n. Protocolos Para cargar la im\u00e1genes se ulitza una llamada HTTP rest d\u00f3nde se especifica; https://.../.../z/x/y.format Z= Nivel de zoom X=coordenada X Y=coordenada Y Formato Raster: Im\u00e1gen png o JPEG Vector: (pbf o mvt) Protocolos Existen tres especificaciones para servir tiles TMS (Tile Map Service): X Y coordenadas empiezan de debajo izquierda (t\u00edpico eje cartesiano de coordenadas) WMTS (Web Map Tile Service): OGC estandard , corrdenadas empiezan de arriba izquierda. ZXY o \"slippy map\": Igual que TMS pero la Y empieza por arriba izquierda Caracteristicas Las teselas vectoriales han sido utilizadas por el cliente Android de Google Maps desde diciembre de 2010 y en el cliente de escritorio desde 2013. Las teselas vectoriales para renderizar los datos de OpenStreetMap se propusieron por primera vez en marzo de 2013 y est\u00e1n soportadas por Mapnik, el renderizador de datos de OpenStreetMap m\u00e1s utilizado. Mapbox, proveedor comercial de herramientas de cartograf\u00eda personalizada y de hosting, es el m\u00e1xini impulsor de esta tecnologia y ha centrado su herramienta de cartograf\u00eda, Mapbox Studio, en torno a las teselas vectoriales. Cada tile es un contenedor de datos vectores y atributos Los Tiles no tienen estilo, el estilo se aplica en cliente Soporta rotaci\u00f3n y orientaci\u00f3n Soporta extrusi\u00f3n y 3D Herramientas y recursos Fuente: https://github.com/mapbox/awesome-vector-tiles Parsers & Generators vector-tile-js - Parses vector tiles with JavaScript. mapnik-vector-tile - C++ vector tile read/write implementation on top of Mapnik. mbtiles-cpp - C++ library for decoding of mbtiles and vector data into function callbacks. vector-tile-py - Python tool to convert a Mapnik vector tile to GeoJSON node-mapnik - Node.js API for vector tiles which depends on mapnik-vector-tile vector-tile-cs - Parses vector tiles with C# (native C# implementation, no dependencies). mapbox-vector-tile-cs - Parses vector tiles with C# (uses protobuf-net). tilelive-bridge - Implements Tilelive API for creating vector tiles from traditional Mapnik datasources in Node.js. tilelive-vector - Implements Tilelive API for reading vector tiles and rendering to image tiles in Node.js. mapbox-vector-tile is a Python package for vector tile encoding. Used in Mapzen's vector tile service tileserver and TileStache. :warning: Only support V1 Tile spec and not V2, no longer maintained geojson-vt - Slice GeoJSON into vector tiles on the fly in the browser. java-vector-tile - A java encoder and decoder for vector tiles. mapbox-vector-tile-java - Encode and decode v2.1 Mapbox Vector Tiles. Convert JTS Geometry to and from MVT features, including simple user data support. Utility functions for converting world coordinates to MVT coordinates and clipping to a tile envelope. cached-vector-tile - An alternative implementation of the vector-tile-js interface, backed by plain JS objects/arrays rather than parsed-on-demand protobuf data. Trades away memory efficiency for faster feature.loadGeometry() calls. tilegrinder - A helper library for applying a data altering function on each vector tile in an MBTiles, using the native protobuf wrapper for de- and encoding, recompressing the results and storing them either in an MBTiles or as single files. SwiftVectorTiles - A Swift encoder for vector tiles according to the Mapbox vector tile spec. orb - A Go geometry library with mvt <-> geojson support. Clients Mapbox GL Native - C++/OpenGL vector maps library with native SDKs for Android, iOS, Node.js, macOS, and Qt Mapbox GL JS - JavaScript/WebGL vector maps library. OpenLayers 3 - JavaScript vector & raster library. WhirlyGlobe/Maply - Objective C code that is able to read and render vector tiles(and style with mapnik xml) on iOS devices. Leaflet.MapboxVectorTile is able to read PBF MapboxVectorTiles from a REST endpoint and render them as a TileLayer on a Leaflet Map. Use this option if you want to utilize vector tiles on a standard Leaflet web map without needing WebGL. CARTO Mobile SDK - C++ maps library focused on offline features, for iOS, Android, Windows Phone and Xamarin with bindings for Java, Objective-C and C#. Based on Nutiteq Maps SDK , but open source and uses CartoCSS. Mapzen Tangram - JavaScript library for rendering 2D & 3D maps live in a web browser with WebGL, supports MVT, GeoJSON, TopoJSON Mapzen Tangram-es - C++ library for rendering 2D and 3D maps using OpenGL ES 2 with custom styling and interactions mapbox-gl-leaflet - Create Mapbox GL layers in Leaflet react-native-mapbox-gl - Render Mapbox GL maps from React applications hoverboard - Render vector tiles on canvas with Leaflet 0.7.x (supports GeoJSON, TopoJSON, and protobuf) :warning: no longer maintained Leaflet.VectorGrid - Display gridded vector data (sliced GeoJSON, TopoJSON or Mapbox Vector Tiles) in Leaflet 1.0.0 ArcGIS API for JavaScript - Draw vector tile layers as part of your web map. Rendering done via mapbox-gl-js integration. mapscii - A Vector Tile to Braille and ASCII renderer for xterm-compatible terminals Unofficial Mapbox GL Native bindings for Qt QML - Qt QML bindings for Qt 5.6 and higher. Mapbox-vector-tiles-basic-js-renderer - A fork of mapbox-gl-js giving you full control over rendering of specific tiles, also provides vector tile overlay for google maps. Applications / Command line tools Mapbox Studio - Web design studio for creating and styling vector tiles. Mapbox Studio Classic - Desktop design studio for both creating vector tiles from raw geodata and for rendering them on-the-fly into image tiles. Internally uses tilelive.js modules to handle vector tiles (see tilelive-bridge and tilelive-vector ) :warning: use Mapbox Studio instead. kosmtik - Design maps with CartoCSS and Mapnik. ArcGIS Pro - Generate vector tiles from maps authored in ArcGIS Pro or imported from ArcMap. MVT Styler - map style editor for vector tiles. Maputnik - A visual style editor for the Mapbox GL style specification. QGIS Vector Tiles Reader - QGIS Python plugin which reads Mapbox Vector Tiles from local MBTiles file or remote mapbox-gl-inspect - Plugin for Mapbox GL JS to view the view and inspect VT features. CLI Utilities mbview - Watch MBTiles in your localhost. View tiles in a basic Mapbox GL JS webapp locally tippecanoe - Build vector tilesets from large collections of GeoJSON features. tilemaker - Command line tool to produce vector tiles directly from an .osm.pbf extract without an intermediate database. mapbox-filter - Filter MBTiles according to Mapbox GL JS styles, shrink MBTiles directly, serve locally over http, publish to S3-compatibile storage vector-tiles-producer Command line tool in C++ to creates vector tiles for a given area at chosen zoom levels using a Mapnik XML. :warning: no longer maintained vt-geojson - decodes vector tiles to GeoJSON FeatureCollections tl - An alternate command line interface to tilelive tileshrink - Reduce the layer extent and simplify the resulting geometries of all vector tiles in an MBTiles tiler @GeoVation - Command line tool for converting GeoJSON, Shapefiles or PostGIS layer to raw Vector Tiles (or MBTiles) tiler @thomersch - Command line tool to convert GeoJSON to Vector Tiles (written in Go language). geojson2mvt - npm package for building a static vector tile tree for given xyz bounds from a geojson file (uses geojson-vt ) OGR MVT and MBTiles - The GDAL/OGR MVT and MBTILES drivers can be used to read and write vector tiles, respectively as tileset on the filesystem or in a mbtiles container (GDAL >= 2.3.0) MBUtil - Import and export MBTiles to disk :warning: no longer maintained Datamaps C application that can be used to create vector tiles and store them in an mbtiles. See the render-vector command. :warning: no longer maintained, use tippecanoe instead Mapbox GL JS Plugins gl-draw - Adds support for drawing and editing features on Mapbox GL JS maps Servers tessera - Supports serving and rendering vector tiles. Uses the same core libraries as Mapbox Studio. tessella - lightweight Node.js Mapbox Vector Tiles server. Inspired by tessera. tilestrata - with tilestrata-vt, it can generate Mapnik Vector Tiles; with tilestrata-postgismvt , it can serve Mapbox Vector Tiles from a PostGIS db Utilery Server to generate vector tiles from PostGIS queries. Python based :warning: no longer maintained tileserver Mapzen Vector Tile Service. TileStache added support for Mapbox Vector tiles via .pbf extension requests. Kartotherian Wikipedia tile server with Tilerator backend tile pre-generator ArcGIS Online - Supports serving vector tiles and rendering in the mapping application powered by the ArcGIS API for JavaScript Portal for ArcGIS - Supports serving vector tiles and rendering in the mapping application powered by the ArcGIS API for JavaScript tilesplash - A light and quick nodejs webserver for serving topojson or mapbox vector tiles from a postgis backend go-vtile-example - An example server written in Go Tegola - A MVT server written in pure Go that supports serving tiles from a PostGIS data provider. t-rex - MVT server in a single executable written in Rust. Serves tiles from PostGIS supporting custom tile grids. OSM Scout Server - Maps server providing vector and raster tiles, geocoder, and router. Designed to be used on Linux (mobile and PC) to provide offline maps; written in C++ postserve - A small Python based tileserver using ST_AsMVT and ST_AsMVTGeom to generate vector tiles on the fly. Designed for use with PostGIS 2.4 and the OpenMapTiles project SpatialServer (PGRestAPI) - A multi-purpose GeoSpatial NodeJS web server created at SpatialDev that not only serves MBTiles stuffed with vector tiles, it can also cut vector tiles on the fly from a PostGIS database. :warning: No longer maintained. OpenMapTiles - Set of open-source tools for self-hosting of OpenStreetMap maps in more than 50 languages. It provides both raster as well as vector tiles, WMS and WMTS services for GIS programs, support for JavaScript viewers and mobile SDK. Hastile - Haskell web server using PostGIS to deliver vector tiles. MapServer - Open Source platform for publishing spatial data and interactive mapping applications to the web. MVT output available in 7.2 Low-level utilities vt-pbf serialize JavaScript objects representing vector tiles into binary Protocol Buffer encodings of vector tiles vtzero - minimalist vector tile decoder and encoder in C++ mvt-fixtures - a suite of valid and invalid test fixtures according to the Mapbox Vector Tile spec versions. Includes simplified unit test fixtures and real-world fixtures to test your encoders and decoders. zellige - command line utility written to convert GeoJSON to MVT. mapbox-gl-function - Mapbox GL style function evaluator :warning: now maintained as party of mapbox-gl-js mapbox-gl-filter-simplify - Simplifies and complexifies filters in Mapbox GL Styles :warning: removed Articles Vector tiles remixed - guide to using tilemaker to generating vector tiles Build Your Own Static Vector Tile Pipeline - guide transforming, encoding and hosting tiles in the cloud; using ogr2ogr + tippecanoe + Mapbox GL JS Using the new MVT function in PostGIS - Building a vector tile service with PostGIS, express, and pg-promise. License","title":"Conceptos Vector Tiles"},{"location":"3_conceptos_vector_tiles/#conceptos-vector-tiles","text":"Vector Tiles es un formato para almacenar datos geogr\u00e1ficos en formato binario (Google Protobuf) y pensados para la visualizaci\u00f3n en navegadores web modernos que soporten webGL. Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (XYZ,WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen. Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos.","title":"Conceptos Vector Tiles"},{"location":"3_conceptos_vector_tiles/#contexto","text":"En 2005 GoogleMaps introdujo una \"nueva\" forma de mostrar datos geogr\u00e1ficos por la web, pregenerando el mapa por niveles de zoom y tiles (teselas) de 256x256 pixeles. Tambi\u00e9n cre\u00f3 una nueva proyecci\u00f3n basada en mercator, llamada pseude-mercator o web mercator , cuyo c\u00f3digo EPSG es 3857 Despu\u00e9s de GoogleMaps, otros proveedores o plataformas c\u00f3mo OpenStreetMap siguen esta misma forma de organizar la geoinformaci\u00f3n.","title":"Contexto"},{"location":"3_conceptos_vector_tiles/#protocolos","text":"Para cargar la im\u00e1genes se ulitza una llamada HTTP rest d\u00f3nde se especifica; https://.../.../z/x/y.format Z= Nivel de zoom X=coordenada X Y=coordenada Y Formato Raster: Im\u00e1gen png o JPEG Vector: (pbf o mvt)","title":"Protocolos"},{"location":"3_conceptos_vector_tiles/#protocolos_1","text":"Existen tres especificaciones para servir tiles TMS (Tile Map Service): X Y coordenadas empiezan de debajo izquierda (t\u00edpico eje cartesiano de coordenadas) WMTS (Web Map Tile Service): OGC estandard , corrdenadas empiezan de arriba izquierda. ZXY o \"slippy map\": Igual que TMS pero la Y empieza por arriba izquierda","title":"Protocolos"},{"location":"3_conceptos_vector_tiles/#caracteristicas","text":"Las teselas vectoriales han sido utilizadas por el cliente Android de Google Maps desde diciembre de 2010 y en el cliente de escritorio desde 2013. Las teselas vectoriales para renderizar los datos de OpenStreetMap se propusieron por primera vez en marzo de 2013 y est\u00e1n soportadas por Mapnik, el renderizador de datos de OpenStreetMap m\u00e1s utilizado. Mapbox, proveedor comercial de herramientas de cartograf\u00eda personalizada y de hosting, es el m\u00e1xini impulsor de esta tecnologia y ha centrado su herramienta de cartograf\u00eda, Mapbox Studio, en torno a las teselas vectoriales. Cada tile es un contenedor de datos vectores y atributos Los Tiles no tienen estilo, el estilo se aplica en cliente Soporta rotaci\u00f3n y orientaci\u00f3n Soporta extrusi\u00f3n y 3D","title":"Caracteristicas"},{"location":"3_conceptos_vector_tiles/#herramientas-y-recursos","text":"Fuente: https://github.com/mapbox/awesome-vector-tiles","title":"Herramientas y recursos"},{"location":"3_conceptos_vector_tiles/#parsers-generators","text":"vector-tile-js - Parses vector tiles with JavaScript. mapnik-vector-tile - C++ vector tile read/write implementation on top of Mapnik. mbtiles-cpp - C++ library for decoding of mbtiles and vector data into function callbacks. vector-tile-py - Python tool to convert a Mapnik vector tile to GeoJSON node-mapnik - Node.js API for vector tiles which depends on mapnik-vector-tile vector-tile-cs - Parses vector tiles with C# (native C# implementation, no dependencies). mapbox-vector-tile-cs - Parses vector tiles with C# (uses protobuf-net). tilelive-bridge - Implements Tilelive API for creating vector tiles from traditional Mapnik datasources in Node.js. tilelive-vector - Implements Tilelive API for reading vector tiles and rendering to image tiles in Node.js. mapbox-vector-tile is a Python package for vector tile encoding. Used in Mapzen's vector tile service tileserver and TileStache. :warning: Only support V1 Tile spec and not V2, no longer maintained geojson-vt - Slice GeoJSON into vector tiles on the fly in the browser. java-vector-tile - A java encoder and decoder for vector tiles. mapbox-vector-tile-java - Encode and decode v2.1 Mapbox Vector Tiles. Convert JTS Geometry to and from MVT features, including simple user data support. Utility functions for converting world coordinates to MVT coordinates and clipping to a tile envelope. cached-vector-tile - An alternative implementation of the vector-tile-js interface, backed by plain JS objects/arrays rather than parsed-on-demand protobuf data. Trades away memory efficiency for faster feature.loadGeometry() calls. tilegrinder - A helper library for applying a data altering function on each vector tile in an MBTiles, using the native protobuf wrapper for de- and encoding, recompressing the results and storing them either in an MBTiles or as single files. SwiftVectorTiles - A Swift encoder for vector tiles according to the Mapbox vector tile spec. orb - A Go geometry library with mvt <-> geojson support.","title":"Parsers &amp; Generators"},{"location":"3_conceptos_vector_tiles/#clients","text":"Mapbox GL Native - C++/OpenGL vector maps library with native SDKs for Android, iOS, Node.js, macOS, and Qt Mapbox GL JS - JavaScript/WebGL vector maps library. OpenLayers 3 - JavaScript vector & raster library. WhirlyGlobe/Maply - Objective C code that is able to read and render vector tiles(and style with mapnik xml) on iOS devices. Leaflet.MapboxVectorTile is able to read PBF MapboxVectorTiles from a REST endpoint and render them as a TileLayer on a Leaflet Map. Use this option if you want to utilize vector tiles on a standard Leaflet web map without needing WebGL. CARTO Mobile SDK - C++ maps library focused on offline features, for iOS, Android, Windows Phone and Xamarin with bindings for Java, Objective-C and C#. Based on Nutiteq Maps SDK , but open source and uses CartoCSS. Mapzen Tangram - JavaScript library for rendering 2D & 3D maps live in a web browser with WebGL, supports MVT, GeoJSON, TopoJSON Mapzen Tangram-es - C++ library for rendering 2D and 3D maps using OpenGL ES 2 with custom styling and interactions mapbox-gl-leaflet - Create Mapbox GL layers in Leaflet react-native-mapbox-gl - Render Mapbox GL maps from React applications hoverboard - Render vector tiles on canvas with Leaflet 0.7.x (supports GeoJSON, TopoJSON, and protobuf) :warning: no longer maintained Leaflet.VectorGrid - Display gridded vector data (sliced GeoJSON, TopoJSON or Mapbox Vector Tiles) in Leaflet 1.0.0 ArcGIS API for JavaScript - Draw vector tile layers as part of your web map. Rendering done via mapbox-gl-js integration. mapscii - A Vector Tile to Braille and ASCII renderer for xterm-compatible terminals Unofficial Mapbox GL Native bindings for Qt QML - Qt QML bindings for Qt 5.6 and higher. Mapbox-vector-tiles-basic-js-renderer - A fork of mapbox-gl-js giving you full control over rendering of specific tiles, also provides vector tile overlay for google maps.","title":"Clients"},{"location":"3_conceptos_vector_tiles/#applications-command-line-tools","text":"Mapbox Studio - Web design studio for creating and styling vector tiles. Mapbox Studio Classic - Desktop design studio for both creating vector tiles from raw geodata and for rendering them on-the-fly into image tiles. Internally uses tilelive.js modules to handle vector tiles (see tilelive-bridge and tilelive-vector ) :warning: use Mapbox Studio instead. kosmtik - Design maps with CartoCSS and Mapnik. ArcGIS Pro - Generate vector tiles from maps authored in ArcGIS Pro or imported from ArcMap. MVT Styler - map style editor for vector tiles. Maputnik - A visual style editor for the Mapbox GL style specification. QGIS Vector Tiles Reader - QGIS Python plugin which reads Mapbox Vector Tiles from local MBTiles file or remote mapbox-gl-inspect - Plugin for Mapbox GL JS to view the view and inspect VT features.","title":"Applications / Command line tools"},{"location":"3_conceptos_vector_tiles/#cli-utilities","text":"mbview - Watch MBTiles in your localhost. View tiles in a basic Mapbox GL JS webapp locally tippecanoe - Build vector tilesets from large collections of GeoJSON features. tilemaker - Command line tool to produce vector tiles directly from an .osm.pbf extract without an intermediate database. mapbox-filter - Filter MBTiles according to Mapbox GL JS styles, shrink MBTiles directly, serve locally over http, publish to S3-compatibile storage vector-tiles-producer Command line tool in C++ to creates vector tiles for a given area at chosen zoom levels using a Mapnik XML. :warning: no longer maintained vt-geojson - decodes vector tiles to GeoJSON FeatureCollections tl - An alternate command line interface to tilelive tileshrink - Reduce the layer extent and simplify the resulting geometries of all vector tiles in an MBTiles tiler @GeoVation - Command line tool for converting GeoJSON, Shapefiles or PostGIS layer to raw Vector Tiles (or MBTiles) tiler @thomersch - Command line tool to convert GeoJSON to Vector Tiles (written in Go language). geojson2mvt - npm package for building a static vector tile tree for given xyz bounds from a geojson file (uses geojson-vt ) OGR MVT and MBTiles - The GDAL/OGR MVT and MBTILES drivers can be used to read and write vector tiles, respectively as tileset on the filesystem or in a mbtiles container (GDAL >= 2.3.0) MBUtil - Import and export MBTiles to disk :warning: no longer maintained Datamaps C application that can be used to create vector tiles and store them in an mbtiles. See the render-vector command. :warning: no longer maintained, use tippecanoe instead","title":"CLI Utilities"},{"location":"3_conceptos_vector_tiles/#mapbox-gl-js-plugins","text":"gl-draw - Adds support for drawing and editing features on Mapbox GL JS maps","title":"Mapbox GL JS Plugins"},{"location":"3_conceptos_vector_tiles/#servers","text":"tessera - Supports serving and rendering vector tiles. Uses the same core libraries as Mapbox Studio. tessella - lightweight Node.js Mapbox Vector Tiles server. Inspired by tessera. tilestrata - with tilestrata-vt, it can generate Mapnik Vector Tiles; with tilestrata-postgismvt , it can serve Mapbox Vector Tiles from a PostGIS db Utilery Server to generate vector tiles from PostGIS queries. Python based :warning: no longer maintained tileserver Mapzen Vector Tile Service. TileStache added support for Mapbox Vector tiles via .pbf extension requests. Kartotherian Wikipedia tile server with Tilerator backend tile pre-generator ArcGIS Online - Supports serving vector tiles and rendering in the mapping application powered by the ArcGIS API for JavaScript Portal for ArcGIS - Supports serving vector tiles and rendering in the mapping application powered by the ArcGIS API for JavaScript tilesplash - A light and quick nodejs webserver for serving topojson or mapbox vector tiles from a postgis backend go-vtile-example - An example server written in Go Tegola - A MVT server written in pure Go that supports serving tiles from a PostGIS data provider. t-rex - MVT server in a single executable written in Rust. Serves tiles from PostGIS supporting custom tile grids. OSM Scout Server - Maps server providing vector and raster tiles, geocoder, and router. Designed to be used on Linux (mobile and PC) to provide offline maps; written in C++ postserve - A small Python based tileserver using ST_AsMVT and ST_AsMVTGeom to generate vector tiles on the fly. Designed for use with PostGIS 2.4 and the OpenMapTiles project SpatialServer (PGRestAPI) - A multi-purpose GeoSpatial NodeJS web server created at SpatialDev that not only serves MBTiles stuffed with vector tiles, it can also cut vector tiles on the fly from a PostGIS database. :warning: No longer maintained. OpenMapTiles - Set of open-source tools for self-hosting of OpenStreetMap maps in more than 50 languages. It provides both raster as well as vector tiles, WMS and WMTS services for GIS programs, support for JavaScript viewers and mobile SDK. Hastile - Haskell web server using PostGIS to deliver vector tiles. MapServer - Open Source platform for publishing spatial data and interactive mapping applications to the web. MVT output available in 7.2","title":"Servers"},{"location":"3_conceptos_vector_tiles/#low-level-utilities","text":"vt-pbf serialize JavaScript objects representing vector tiles into binary Protocol Buffer encodings of vector tiles vtzero - minimalist vector tile decoder and encoder in C++ mvt-fixtures - a suite of valid and invalid test fixtures according to the Mapbox Vector Tile spec versions. Includes simplified unit test fixtures and real-world fixtures to test your encoders and decoders. zellige - command line utility written to convert GeoJSON to MVT. mapbox-gl-function - Mapbox GL style function evaluator :warning: now maintained as party of mapbox-gl-js mapbox-gl-filter-simplify - Simplifies and complexifies filters in Mapbox GL Styles :warning: removed","title":"Low-level utilities"},{"location":"3_conceptos_vector_tiles/#articles","text":"Vector tiles remixed - guide to using tilemaker to generating vector tiles Build Your Own Static Vector Tile Pipeline - guide transforming, encoding and hosting tiles in the cloud; using ogr2ogr + tippecanoe + Mapbox GL JS Using the new MVT function in PostGIS - Building a vector tile service with PostGIS, express, and pg-promise.","title":"Articles"},{"location":"3_conceptos_vector_tiles/#license","text":"","title":"License"},{"location":"3_estandares_ISO/","text":"Est\u00e1ndares ISO Para la creaci\u00f3n de metadatos (tanto de datos como de servicios), ISO ha creado los siguientes est\u00e1ndares: ISO 19115, ISO 19119 y ISO 19139; mientras que para el dise\u00f1o de geoservicios, OGC ha dise\u00f1ado los siguientes: WMS, WFS, WCS, GML. Algunos de estos han sido adoptados tambi\u00e9n por ISO, convirti\u00e9ndose as\u00ed en est\u00e1ndares internacionales. Qu\u00e9 es ISO? Familia ISO19x ISO 19115 ISO 19119 ISO 19139 Ejemplos de implementaci\u00f3n de est\u00e1ndares","title":"3. Est\u00e1ndares ISO"},{"location":"3_estandares_ISO/#estandares-iso","text":"Para la creaci\u00f3n de metadatos (tanto de datos como de servicios), ISO ha creado los siguientes est\u00e1ndares: ISO 19115, ISO 19119 y ISO 19139; mientras que para el dise\u00f1o de geoservicios, OGC ha dise\u00f1ado los siguientes: WMS, WFS, WCS, GML. Algunos de estos han sido adoptados tambi\u00e9n por ISO, convirti\u00e9ndose as\u00ed en est\u00e1ndares internacionales. Qu\u00e9 es ISO? Familia ISO19x ISO 19115 ISO 19119 ISO 19139 Ejemplos de implementaci\u00f3n de est\u00e1ndares","title":"Est\u00e1ndares ISO"},{"location":"4_visualizacion_kepler/","text":"Visualizaci\u00f3n con Kepler.gl Kepler.gl desrrollada por Uber, en u principio para uso interno, para analizar y visualizar sus propios datos. Es una aplicaci\u00f3n basada en web GL de alto rendimiento y agn\u00f3stica de datos para la exploraci\u00f3n visual de conjuntos de datos de geolocalizaci\u00f3n a gran escala. Construido en la parte superior de deck.gl, kepler.gl puede representar millones de puntos que representan miles de viajes y realizar agregaciones espaciales sobre la marcha. Ejercicio de visualizaci\u00f3n con Kepler.gl Tip Queremos ver d\u00f3nde hay m\u00e1s accidentes Descargamos dataset CSV de OpenData BCN Vamos a http://kepler.gl/#/demo A\u00f1adimos csv Add Layer: Type Hexbin Columns: Latitud Longuitud Color: Scale Quantize Hexagon radius 0.1 Coverage 0.75 Info Continuamos a\u00f1adiendo m\u00e1s capas y mapas bases","title":"4. Visualizaci\u00f3n con Kepler.gl"},{"location":"4_visualizacion_kepler/#visualizacion-con-keplergl","text":"Kepler.gl desrrollada por Uber, en u principio para uso interno, para analizar y visualizar sus propios datos. Es una aplicaci\u00f3n basada en web GL de alto rendimiento y agn\u00f3stica de datos para la exploraci\u00f3n visual de conjuntos de datos de geolocalizaci\u00f3n a gran escala. Construido en la parte superior de deck.gl, kepler.gl puede representar millones de puntos que representan miles de viajes y realizar agregaciones espaciales sobre la marcha.","title":"Visualizaci\u00f3n con Kepler.gl"},{"location":"4_visualizacion_kepler/#ejercicio-de-visualizacion-con-keplergl","text":"Tip Queremos ver d\u00f3nde hay m\u00e1s accidentes Descargamos dataset CSV de OpenData BCN Vamos a http://kepler.gl/#/demo A\u00f1adimos csv Add Layer: Type Hexbin Columns: Latitud Longuitud Color: Scale Quantize Hexagon radius 0.1 Coverage 0.75 Info Continuamos a\u00f1adiendo m\u00e1s capas y mapas bases","title":"Ejercicio de visualizaci\u00f3n con Kepler.gl"},{"location":"5_herramientas_visualizacion_datos/","text":"Herramientas de visualizaci\u00f3n de datos Librer\u00edas Debido a que los datos que podemos encotrar en un portal de Opendata pueden variar mucho tanto en formato como en el tipo; lo mejor para visualizarlos es utilizar librer\u00edas gen\u00e9ricas de visualizaci\u00f3n de datos. Entre las principales tenemos: https://d3js.org/ https://vega.github.io/vega/ https://p5js.org/examples/ http://www.chartjs.org/ https://www.highcharts.com/products/highcharts/ Servicios Aparte de estas librer\u00edas que nos permiten desarrollar nuestras aplicaciones de visualizaci\u00f3n de datos tambi\u00e9n existen algunos servicios conocidos como BI (Business Intelligence) que aparte de mostrar los datos tambi\u00e9n nos permiten hacer ciertos an\u00e1lisis. Algunos de los principales servicios son: https://www.tableau.com/ https://www.qlik.com/es-es http://www.pentaho.com/ https://powerbi.microsoft.com/es-es/","title":"5. Herramientas de visualizaci\u00f3n de datos"},{"location":"5_herramientas_visualizacion_datos/#herramientas-de-visualizacion-de-datos","text":"","title":"Herramientas de visualizaci\u00f3n de datos"},{"location":"5_herramientas_visualizacion_datos/#librerias","text":"Debido a que los datos que podemos encotrar en un portal de Opendata pueden variar mucho tanto en formato como en el tipo; lo mejor para visualizarlos es utilizar librer\u00edas gen\u00e9ricas de visualizaci\u00f3n de datos. Entre las principales tenemos: https://d3js.org/ https://vega.github.io/vega/ https://p5js.org/examples/ http://www.chartjs.org/ https://www.highcharts.com/products/highcharts/","title":"Librer\u00edas"},{"location":"5_herramientas_visualizacion_datos/#servicios","text":"Aparte de estas librer\u00edas que nos permiten desarrollar nuestras aplicaciones de visualizaci\u00f3n de datos tambi\u00e9n existen algunos servicios conocidos como BI (Business Intelligence) que aparte de mostrar los datos tambi\u00e9n nos permiten hacer ciertos an\u00e1lisis. Algunos de los principales servicios son: https://www.tableau.com/ https://www.qlik.com/es-es http://www.pentaho.com/ https://powerbi.microsoft.com/es-es/","title":"Servicios"},{"location":"6_conceptos_geoservicios/","text":"Conceptos b\u00e1sicos de Geoservicios Recursos La mayor\u00edas de los conceptos son sacados del Libro libre SIG de Victor Olaya http://volaya.github.io/libro-sig/ Geoservicio Un geoservicio es un servidor que ofrece alg\u00fan servicio relacionado con el \u00e1mbito SIG, su principal funci\u00f3n es acceder a informaci\u00f3n geoespacial existente en diferentes formatos y servir dicha informaci\u00f3n a clientes a trav\u00e9s de protocolos est\u00e1ndares. El servidor es el elemento encargado de ofrecer el servicio como tal, respondiendo a las peticiones del cliente. A medida que los clientes se hacen m\u00e1s complejos y presentan mayor n\u00famero de funcionalidades, tambi\u00e9n los servidores deben ser capaces de proporcionar servicios m\u00e1s elaborados. Las capacidades fundamentales a las que responden los servidores dentro del \u00e1mbito SIG pueden dividirse en los siguientes grupos: Servir representaciones de los datos. Los servicios de cartograf\u00eda Web, tanto en sus or\u00edgenes como en la actualidad, son eminentemente gr\u00e1ficos, y en \u00faltima instancia lo que la aplicaci\u00f3n Web correspondiente va a hacer es mostrarnos alg\u00fan tipo de imagen con un mapa formado a partir de una serie de datos geogr\u00e1ficos. Ejemplo WMS El servidor puede responder directamente a este tipo de necesidades, preparando una imagen a partir de los datos geogr\u00e1ficos de los que dispone. En el caso de que estos sean ya im\u00e1genes \u2014por ejemplo, im\u00e1genes de sat\u00e9lite u ortofotos\u2014, bastar\u00e1 servir estas, transmitiendo una versi\u00f3n escalada de las dimensiones exactas que el cliente necesite para representar en pantalla. En caso de que los datos sean de tipo vectorial, o bien r\u00e1ster sin una forma de representaci\u00f3n impl\u00edcita \u2014por ejemplo, un Modelo Digital del Terreno\u2014 es necesario emplear alg\u00fan m\u00e9todo para asignarles dicha representaci\u00f3n. Este puede ser asignado por defecto por el servidor, que establecer\u00e1 una simbolog\u00eda fija, o bien ofrecer un servicio m\u00e1s complejo en el que el cliente no solo pide una representaci\u00f3n gr\u00e1fica de una serie de datos para una zona dada, sino que adem\u00e1s puede especificar c\u00f3mo crear esa representaci\u00f3n (v\u00eda SLD). Servir los datos directamente. Una opci\u00f3n m\u00e1s flexible que lo anterior es que el servidor provea directamente los datos geogr\u00e1ficos y sea despu\u00e9s el cliente quien los utilice como corresponda, bien sea simplemente represent\u00e1ndolos \u2014en cuyo caso deber\u00eda ser el propio cliente quien establezca la simbolog\u00eda, ya que esta tarea ya no queda en manos del servidor\u2014 o bien trabajando con ellos de cualquier otra forma, como por ejemplo analiz\u00e1ndolos. Ejemplo WFS Aunque las posibilidades son mayores en este caso, se requieren por parte del cliente unas capacidades mayores, ya que mientras que representar una imagen es algo sumamente sencillo desde el punto de vista t\u00e9cnico, crear esta a partir de los datos geogr\u00e1ficos es m\u00e1s complejo. Servir consultas. Un paso m\u00e1s all\u00e1 en la funcionalidad que puede ofrecer el servidor es responder a preguntas realizadas por el cliente relativas a los datos, ya sean estas relativas a la parte espacial de dichos datos, o bien a su componente tem\u00e1tica. El servidor puede ofrecer como respuesta conjuntos reducidos de los datos de los que dispone, o valores que describan a estos. Estas consultas pueden ser \u00fatiles, por ejemplo, para establecer filtros previos cuando se dispone de un conjunto amplio de or\u00edgenes de datos. Un cliente Web puede obtener datos de distintos servidores, y puede consultar si, para un zona dada, estos servidores disponen de informaci\u00f3n, sin m\u00e1s que consultar la extensi\u00f3n cubierta por los datos de cada uno de ellos y comprobar si se interseca con la regi\u00f3n de inter\u00e9s. En funci\u00f3n de la respuesta, puede o no realizarse posteriormente el acceso a los datos en s\u00ed. Ejemplo CSW Servir procesos. Por \u00faltimo, un servidor puede ofrecer nuevos datos, espaciales o no espaciales, resultantes de alg\u00fan tipo de proceso o c\u00e1lculo a partir de datos espaciales. En este caso, el proceso constituye en s\u00ed el servicio ofrecido por el servidor, y el cliente debe definir los par\u00e1metros de entrada de este y los posibles par\u00e1metros de ajuste que resulten necesarios. Los datos con los que se trabaja pueden ser proporcionados por el cliente, incorpor\u00e1ndolos a su propia petici\u00f3n, o bien pueden residir en el propio servidor. En este \u00faltimo caso, el servidor ofrece tanto los datos, como la posibilidad de extraer resultados a partir de ellos, es decir, los datos y una herramienta para explotarlos. Tambi\u00e9n pueden emplearse datos en un servidor distinto, a los que el servidor de procesos puede acceder si estos est\u00e1n disponibles, convirti\u00e9ndose en cliente de ese segundo servidor. Ejemplo WPS Las posibilidades que estos servicios brindan son muy numerosas. Por una parte, pueden a\u00f1adirse funcionalidades avanzadas a interfaces Web, llevando a estas las capacidades propias de los SIG de escritorio. Por otra, la difusi\u00f3n de algoritmos de an\u00e1lisis geogr\u00e1fico resulta m\u00e1s sencilla, pudiendo ofrecerse estos a todo tipo de usuarios sin necesidad de ning\u00fan software especializado. Y por \u00faltimo, en ciertos casos pueden rebajarse los tiempos de proceso, ya que, en el caso de operaciones complejas, la mayor potencia del servidor respecto al cliente puede resultar en un mayor rendimiento. El reparto de tareas entre varios servidores (computaci\u00f3n distribuida) es otra de las posibilidades que pueden a su vez ampliar la eficiencia de los procesos. Referencias Libro libre SIG de Victor Olaya http://volaya.github.io/libro-sig/","title":"6. Conceptos b\u00e1sicos de Geoservicios"},{"location":"6_conceptos_geoservicios/#conceptos-basicos-de-geoservicios","text":"Recursos La mayor\u00edas de los conceptos son sacados del Libro libre SIG de Victor Olaya http://volaya.github.io/libro-sig/","title":"Conceptos b\u00e1sicos de Geoservicios"},{"location":"6_conceptos_geoservicios/#geoservicio","text":"Un geoservicio es un servidor que ofrece alg\u00fan servicio relacionado con el \u00e1mbito SIG, su principal funci\u00f3n es acceder a informaci\u00f3n geoespacial existente en diferentes formatos y servir dicha informaci\u00f3n a clientes a trav\u00e9s de protocolos est\u00e1ndares. El servidor es el elemento encargado de ofrecer el servicio como tal, respondiendo a las peticiones del cliente. A medida que los clientes se hacen m\u00e1s complejos y presentan mayor n\u00famero de funcionalidades, tambi\u00e9n los servidores deben ser capaces de proporcionar servicios m\u00e1s elaborados. Las capacidades fundamentales a las que responden los servidores dentro del \u00e1mbito SIG pueden dividirse en los siguientes grupos: Servir representaciones de los datos. Los servicios de cartograf\u00eda Web, tanto en sus or\u00edgenes como en la actualidad, son eminentemente gr\u00e1ficos, y en \u00faltima instancia lo que la aplicaci\u00f3n Web correspondiente va a hacer es mostrarnos alg\u00fan tipo de imagen con un mapa formado a partir de una serie de datos geogr\u00e1ficos. Ejemplo WMS El servidor puede responder directamente a este tipo de necesidades, preparando una imagen a partir de los datos geogr\u00e1ficos de los que dispone. En el caso de que estos sean ya im\u00e1genes \u2014por ejemplo, im\u00e1genes de sat\u00e9lite u ortofotos\u2014, bastar\u00e1 servir estas, transmitiendo una versi\u00f3n escalada de las dimensiones exactas que el cliente necesite para representar en pantalla. En caso de que los datos sean de tipo vectorial, o bien r\u00e1ster sin una forma de representaci\u00f3n impl\u00edcita \u2014por ejemplo, un Modelo Digital del Terreno\u2014 es necesario emplear alg\u00fan m\u00e9todo para asignarles dicha representaci\u00f3n. Este puede ser asignado por defecto por el servidor, que establecer\u00e1 una simbolog\u00eda fija, o bien ofrecer un servicio m\u00e1s complejo en el que el cliente no solo pide una representaci\u00f3n gr\u00e1fica de una serie de datos para una zona dada, sino que adem\u00e1s puede especificar c\u00f3mo crear esa representaci\u00f3n (v\u00eda SLD). Servir los datos directamente. Una opci\u00f3n m\u00e1s flexible que lo anterior es que el servidor provea directamente los datos geogr\u00e1ficos y sea despu\u00e9s el cliente quien los utilice como corresponda, bien sea simplemente represent\u00e1ndolos \u2014en cuyo caso deber\u00eda ser el propio cliente quien establezca la simbolog\u00eda, ya que esta tarea ya no queda en manos del servidor\u2014 o bien trabajando con ellos de cualquier otra forma, como por ejemplo analiz\u00e1ndolos. Ejemplo WFS Aunque las posibilidades son mayores en este caso, se requieren por parte del cliente unas capacidades mayores, ya que mientras que representar una imagen es algo sumamente sencillo desde el punto de vista t\u00e9cnico, crear esta a partir de los datos geogr\u00e1ficos es m\u00e1s complejo. Servir consultas. Un paso m\u00e1s all\u00e1 en la funcionalidad que puede ofrecer el servidor es responder a preguntas realizadas por el cliente relativas a los datos, ya sean estas relativas a la parte espacial de dichos datos, o bien a su componente tem\u00e1tica. El servidor puede ofrecer como respuesta conjuntos reducidos de los datos de los que dispone, o valores que describan a estos. Estas consultas pueden ser \u00fatiles, por ejemplo, para establecer filtros previos cuando se dispone de un conjunto amplio de or\u00edgenes de datos. Un cliente Web puede obtener datos de distintos servidores, y puede consultar si, para un zona dada, estos servidores disponen de informaci\u00f3n, sin m\u00e1s que consultar la extensi\u00f3n cubierta por los datos de cada uno de ellos y comprobar si se interseca con la regi\u00f3n de inter\u00e9s. En funci\u00f3n de la respuesta, puede o no realizarse posteriormente el acceso a los datos en s\u00ed. Ejemplo CSW Servir procesos. Por \u00faltimo, un servidor puede ofrecer nuevos datos, espaciales o no espaciales, resultantes de alg\u00fan tipo de proceso o c\u00e1lculo a partir de datos espaciales. En este caso, el proceso constituye en s\u00ed el servicio ofrecido por el servidor, y el cliente debe definir los par\u00e1metros de entrada de este y los posibles par\u00e1metros de ajuste que resulten necesarios. Los datos con los que se trabaja pueden ser proporcionados por el cliente, incorpor\u00e1ndolos a su propia petici\u00f3n, o bien pueden residir en el propio servidor. En este \u00faltimo caso, el servidor ofrece tanto los datos, como la posibilidad de extraer resultados a partir de ellos, es decir, los datos y una herramienta para explotarlos. Tambi\u00e9n pueden emplearse datos en un servidor distinto, a los que el servidor de procesos puede acceder si estos est\u00e1n disponibles, convirti\u00e9ndose en cliente de ese segundo servidor. Ejemplo WPS Las posibilidades que estos servicios brindan son muy numerosas. Por una parte, pueden a\u00f1adirse funcionalidades avanzadas a interfaces Web, llevando a estas las capacidades propias de los SIG de escritorio. Por otra, la difusi\u00f3n de algoritmos de an\u00e1lisis geogr\u00e1fico resulta m\u00e1s sencilla, pudiendo ofrecerse estos a todo tipo de usuarios sin necesidad de ning\u00fan software especializado. Y por \u00faltimo, en ciertos casos pueden rebajarse los tiempos de proceso, ya que, en el caso de operaciones complejas, la mayor potencia del servidor respecto al cliente puede resultar en un mayor rendimiento. El reparto de tareas entre varios servidores (computaci\u00f3n distribuida) es otra de las posibilidades que pueden a su vez ampliar la eficiencia de los procesos.","title":"Geoservicio"},{"location":"6_conceptos_geoservicios/#referencias","text":"Libro libre SIG de Victor Olaya http://volaya.github.io/libro-sig/","title":"Referencias"},{"location":"7_ejemplo_servicio_wms/","text":"Ejemplo servicio WMS Acceso al servicio WMS La manera m\u00e1s f\u00e1cil de encontrar las url de los servicios WMS es buscando en la IDE correspondiente o si conocemos al proveedor del servicio buscando en su p\u00e1gina web. En el portal del PNOA podemos encontrar los diferentes productos y servicios que ofrece. Otro ejemplo tambi\u00e9n ser\u00eda la web del Institut Cartogr\u00e0fic i Geol\u00f2gic de Catalunya (ICGC) La url del servicio WMS de Ortofotos del PNOA es: http://www.ign.es/wms-inspire/pnoa-ma?request=GetCapabilities&service=WMS Para ver las capacidades y descripci\u00f3n del servicio tenemos que hacer una consulta GetCapabilities http://www.ign.es/wms-inspire/pnoa-ma?request=GetCapabilities&service=WMS . Al abrir la consulta en nuestro navegador vemos un XML donde se describe el servicio y donde podremos sacar los par\u00e1metros necesarios para poder visualizar el servicio en nuestro visor de mapas. Para ver los datos de este servicio sobre un mapa crearemos un visor utilizando Leaflet. 1 Creaci\u00f3n de un visor Crear una carpeta con el nombre de visor-wms . Crear un archivo con el nombre de index.html dentro de la carpeta Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de WMS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" integrity = \"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==\" crossorigin = \"\" /> < style > # mapid { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"mapid\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" integrity = \"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==\" crossorigin = \"\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'mapid' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para ver que carga un mapa centrado en Barcelona. Agregar la capa WMS del PNOA <!DOCTYPE html> < html > < head > < title > Servicio de WMS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" integrity = \"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==\" crossorigin = \"\" /> < style > # mapid { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"mapid\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" integrity = \"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==\" crossorigin = \"\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'mapid' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var pnoa = L . tileLayer . wms ( \"http://www.ign.es/wms-inspire/pnoa-ma?SERVICE=WMS&\" , { layers : 'OI.OrthoimageCoverage' , format : 'image/png' , transparent : true , version : '1.3.0' , //wms version (ver get capabilities) attribution : \"PNOA WMS. Cedido por \u00a9 Instituto Geogr\u00e1fico Nacional de Espa\u00f1a\" }). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina para visualizar nuestra capa WMS de Ortofotos. Ejercicio Agregar el servicio WMS de Ortofotos del ICGC. URL del servicio http://geoserveis.icc.cat/icc_mapesmultibase/noutm/wms/service ? Para ver el nombre de la capa (layers) hacer un GetCapabilities http://geoserveis.icc.cat/icc_mapesmultibase/noutm/wms/service?SERVICE=WMS&VERSION=1.3.0&REQUEST=Getcapabilities . En el par\u00e1metro attribution de la nueva capa poner \"Institut Cartogr\u00e0fic i Geol\u00f2gic de Catalunya\" Referencias http://leafletjs.com/ \u21a9","title":"7. Ejemplo servicio WMS"},{"location":"7_ejemplo_servicio_wms/#ejemplo-servicio-wms","text":"","title":"Ejemplo servicio WMS"},{"location":"7_ejemplo_servicio_wms/#acceso-al-servicio-wms","text":"La manera m\u00e1s f\u00e1cil de encontrar las url de los servicios WMS es buscando en la IDE correspondiente o si conocemos al proveedor del servicio buscando en su p\u00e1gina web. En el portal del PNOA podemos encontrar los diferentes productos y servicios que ofrece. Otro ejemplo tambi\u00e9n ser\u00eda la web del Institut Cartogr\u00e0fic i Geol\u00f2gic de Catalunya (ICGC) La url del servicio WMS de Ortofotos del PNOA es: http://www.ign.es/wms-inspire/pnoa-ma?request=GetCapabilities&service=WMS Para ver las capacidades y descripci\u00f3n del servicio tenemos que hacer una consulta GetCapabilities http://www.ign.es/wms-inspire/pnoa-ma?request=GetCapabilities&service=WMS . Al abrir la consulta en nuestro navegador vemos un XML donde se describe el servicio y donde podremos sacar los par\u00e1metros necesarios para poder visualizar el servicio en nuestro visor de mapas. Para ver los datos de este servicio sobre un mapa crearemos un visor utilizando Leaflet. 1","title":"Acceso al servicio WMS"},{"location":"7_ejemplo_servicio_wms/#creacion-de-un-visor","text":"Crear una carpeta con el nombre de visor-wms . Crear un archivo con el nombre de index.html dentro de la carpeta Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de WMS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" integrity = \"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==\" crossorigin = \"\" /> < style > # mapid { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"mapid\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" integrity = \"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==\" crossorigin = \"\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'mapid' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para ver que carga un mapa centrado en Barcelona. Agregar la capa WMS del PNOA <!DOCTYPE html> < html > < head > < title > Servicio de WMS </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" integrity = \"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==\" crossorigin = \"\" /> < style > # mapid { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"mapid\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" integrity = \"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==\" crossorigin = \"\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'mapid' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var pnoa = L . tileLayer . wms ( \"http://www.ign.es/wms-inspire/pnoa-ma?SERVICE=WMS&\" , { layers : 'OI.OrthoimageCoverage' , format : 'image/png' , transparent : true , version : '1.3.0' , //wms version (ver get capabilities) attribution : \"PNOA WMS. Cedido por \u00a9 Instituto Geogr\u00e1fico Nacional de Espa\u00f1a\" }). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina para visualizar nuestra capa WMS de Ortofotos. Ejercicio Agregar el servicio WMS de Ortofotos del ICGC. URL del servicio http://geoserveis.icc.cat/icc_mapesmultibase/noutm/wms/service ? Para ver el nombre de la capa (layers) hacer un GetCapabilities http://geoserveis.icc.cat/icc_mapesmultibase/noutm/wms/service?SERVICE=WMS&VERSION=1.3.0&REQUEST=Getcapabilities . En el par\u00e1metro attribution de la nueva capa poner \"Institut Cartogr\u00e0fic i Geol\u00f2gic de Catalunya\"","title":"Creaci\u00f3n de un visor"},{"location":"7_ejemplo_servicio_wms/#referencias","text":"http://leafletjs.com/ \u21a9","title":"Referencias"},{"location":"8_consideraciones_servicios_opendata/","text":"Consideraciones sobre servicios Open data Problemas frecuentes al trabajar con servicios Open Data Ausencia de normalizaci\u00f3n u homogeneidad en los portales y servicios. Datos en formatos cerrados o no reutilizables como el pdf. Cambio de las direcciones de los recursos. Por ejemplo, suele ocurrir que cuando se cambia el nombre de un servidor \u00f3 la t\u00e9cnolog\u00eda del portal ocasiona un cambio en las URLs y dejan de funcionar las aplicaciones y servicios que consumen esos datos. Datos poco fiables, err\u00f3neos, inconsistentes. Falta de normalizaci\u00f3n y homogeneidad tambi\u00e9n en los datos. Ejemplo https://analisi.transparenciacatalunya.cat/Urbanisme-infraestructures/Equipaments-de-Catalunya/8gmd-gz7i Ejemplo de buenas pr\u00e1cticas Un buen ejemplo de servicios realtime Open Data son los servicios de notificaci\u00f3n de terremotos de el USGS porque est\u00e1n muy bien documentados, tienen salida en m\u00faltiples formatos, son gratuitos y de libre acceso y ofrecen diferentes niveles de usuarios (programadores y no programadores) https://earthquake.usgs.gov/earthquakes/feed/v1.0/geojson.php Ejemplo de \"malas\" pr\u00e1cticas En el servicio OpenData de la AEMET http://www.aemet.es/es/datos_abiertos/AEMET_OpenData observamos que nos solicitan una API Key para acceder a los servicios y para obtenerla hay que dar una direcci\u00f3n de email y resolver un captcha, lo que constituye una barrera de entrada. Luego, existe una diferencia clara entre desarrolladores y el acceso general. Y en ninguno de los perfiles de usuarios hay un acceso f\u00e1cil, directo y claro a la informaci\u00f3n. Lo vemos cuando solicitamos un recurso, que nos retorna un json apuntando a otro recurso. Ejemplo https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/diaria/08001?api_key=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2xvc2lnQGdtYWlsLmNvbSIsImp0aSI6ImFkMzFlYjhmLTYxYmQtNGUxMi05Y2E0LTE4MGU4M2UzYzkwNSIsImlzcyI6IkFFTUVUIiwiaWF0IjoxNTExOTgzOTI2LCJ1c2VySWQiOiJhZDMxZWI4Zi02MWJkLTRlMTItOWNhNC0xODBlODNlM2M5MDUiLCJyb2xlIjoiIn0.YYQ93aedA5RM6WTp8XR-gDw3XyMeMxYrCEddDbSpwhU Retorna { \"descripcion\" : \"exito\" , \"estado\" : 200 , \"datos\" : \"https://opendata.aemet.es/opendata/sh/36188a6b\" , \"metadatos\" : \"https://opendata.aemet.es/opendata/sh/dfd88b22\" } Datos https://opendata.aemet.es/opendata/sh/36188a6b Metadatos https://opendata.aemet.es/opendata/sh/dfd88b22","title":"8. Consideraciones sobre servicios Open data"},{"location":"8_consideraciones_servicios_opendata/#consideraciones-sobre-servicios-open-data","text":"","title":"Consideraciones sobre servicios Open data"},{"location":"8_consideraciones_servicios_opendata/#problemas-frecuentes-al-trabajar-con-servicios-open-data","text":"Ausencia de normalizaci\u00f3n u homogeneidad en los portales y servicios. Datos en formatos cerrados o no reutilizables como el pdf. Cambio de las direcciones de los recursos. Por ejemplo, suele ocurrir que cuando se cambia el nombre de un servidor \u00f3 la t\u00e9cnolog\u00eda del portal ocasiona un cambio en las URLs y dejan de funcionar las aplicaciones y servicios que consumen esos datos. Datos poco fiables, err\u00f3neos, inconsistentes. Falta de normalizaci\u00f3n y homogeneidad tambi\u00e9n en los datos. Ejemplo https://analisi.transparenciacatalunya.cat/Urbanisme-infraestructures/Equipaments-de-Catalunya/8gmd-gz7i","title":"Problemas frecuentes al trabajar con servicios Open Data"},{"location":"8_consideraciones_servicios_opendata/#ejemplo-de-buenas-practicas","text":"Un buen ejemplo de servicios realtime Open Data son los servicios de notificaci\u00f3n de terremotos de el USGS porque est\u00e1n muy bien documentados, tienen salida en m\u00faltiples formatos, son gratuitos y de libre acceso y ofrecen diferentes niveles de usuarios (programadores y no programadores) https://earthquake.usgs.gov/earthquakes/feed/v1.0/geojson.php","title":"Ejemplo de buenas pr\u00e1cticas"},{"location":"8_consideraciones_servicios_opendata/#ejemplo-de-malas-practicas","text":"En el servicio OpenData de la AEMET http://www.aemet.es/es/datos_abiertos/AEMET_OpenData observamos que nos solicitan una API Key para acceder a los servicios y para obtenerla hay que dar una direcci\u00f3n de email y resolver un captcha, lo que constituye una barrera de entrada. Luego, existe una diferencia clara entre desarrolladores y el acceso general. Y en ninguno de los perfiles de usuarios hay un acceso f\u00e1cil, directo y claro a la informaci\u00f3n. Lo vemos cuando solicitamos un recurso, que nos retorna un json apuntando a otro recurso. Ejemplo https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/diaria/08001?api_key=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2xvc2lnQGdtYWlsLmNvbSIsImp0aSI6ImFkMzFlYjhmLTYxYmQtNGUxMi05Y2E0LTE4MGU4M2UzYzkwNSIsImlzcyI6IkFFTUVUIiwiaWF0IjoxNTExOTgzOTI2LCJ1c2VySWQiOiJhZDMxZWI4Zi02MWJkLTRlMTItOWNhNC0xODBlODNlM2M5MDUiLCJyb2xlIjoiIn0.YYQ93aedA5RM6WTp8XR-gDw3XyMeMxYrCEddDbSpwhU Retorna { \"descripcion\" : \"exito\" , \"estado\" : 200 , \"datos\" : \"https://opendata.aemet.es/opendata/sh/36188a6b\" , \"metadatos\" : \"https://opendata.aemet.es/opendata/sh/dfd88b22\" } Datos https://opendata.aemet.es/opendata/sh/36188a6b Metadatos https://opendata.aemet.es/opendata/sh/dfd88b22","title":"Ejemplo de \"malas\" pr\u00e1cticas"},{"location":"9_ejemplo_servicio_bicing_bcn/","text":"Ejemplo servicio bicing Barcelona Acceso al servicio de datos del Bicing de Barcelona En el portal Open data del Ayuntamiento de Barcelona podemos encontrar un dataset (conjunto de datos) que contiene las estaciones del servicio de Bicing Anteriormente ten\u00edan un servicio donde daban toda la informaci\u00f3n de la estaci\u00f3n en tiempo real http://wservice.viabicing.cat/v2/stations . Actualmente lo han separado en dos servicios unos con la informaci\u00f3n de las estaciones (identificador, nombre, coordenadas, etc.) y otro con estado de las estaciones (n\u00famero de bicis disponibles, tipos de bicis, etc) Si bien el Ayuntamiento de Barcelona no ofrece explicitamente el acceso a los datos del Bicing como un servicio, si que tiene un servicio de datos en tiempo real. La url la podemos encontrar presionando el bot\u00f3n de Descargar del recurso json url servicio de bicing Al abrir la url https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information en nuestro navegador observaremos que la respuesta es un archivo json con un conjunto de elementos que tienen las coordenadas de la localizaci\u00f3n de la estaci\u00f3n de bicing, la direcci\u00f3n, la capacidad, etc. Mapa que utiliza este servicio, https://www.bicing.barcelona/es/mapa-de-disponibilidad-provisional El archivo json que retorna el servicio tiene coordenadas pero no es un fichero GeoJSON. 1 Para ver estos datos sobre un mapa crearemos un visor utilizando Leaflet. 2 Creaci\u00f3n de un visor Crear una carpeta con el nombre de visor-bicing . Crear un archivo con el nombre de index.html dentro de la carpeta Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para ver que carga un mapa centrado en Barcelona. Agregar el plugin para cargar datos en tiempo real. Para ellos utilizaremos el plugin Leaflet Realtime 3 . Copiar lo siguiente justo despu\u00e9s de cuando carguemos la libreria de Leaflet. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Agregar la capa de realtime del bicing a nuestro mapa. Siguiendo el ejemplo b\u00e1sico del plugin para cagar una capa, copiar lo siguiente al final de nuestro c\u00f3digo de javascript. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var realtime = L . realtime ({ url : 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' , crossOrigin : true , type : 'json' }, { interval : 3 * 1000 }). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina para visualizar nuestra capa de bicing. Observaremos que no aparece ning\u00fan dato. Abrir la consola de desarrollador del navegador presionando F12 y veremos que cada 3 segundos aparecer\u00e1 un error. El error es Error: Invalid GeoJSON object. . Este error es debido a lo que ya comentamos; la respuesta del servicio de Bicing no es un GeoJSON. Crear una variable llamada geojson que ser\u00e1 la que contendr\u00e1 el GeoJSON resultante de la transformaci\u00f3n, antes de la declaraci\u00f3n de nuestra capa de realtime <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojson = { type : 'FeatureCollection' , features : [] }; var realtime = L . realtime ({ url : 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' , crossOrigin : true , type : 'json' }, { interval : 3 * 1000 }). addTo ( map ); </ script > </ body > </ html > Modificar la aplicaci\u00f3n para transformar la respuesta del bicing en un GeoJSON. Modificar nuestra capa realtime con el siguiente c\u00f3digo <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojson = { type : 'FeatureCollection' , features : [] }; var realtime = L . realtime ( function ( success , error ) { fetch ( 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ) . then ( function ( response ) { return response . json (); }) . then ( function ( data ) { var stations = data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , name : station . name , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } success ( geojson ); }) . catch ( error ); }, { interval : 3 * 1000 }). addTo ( map ); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos los puntos de las estaciones de bicing. Si vamos a la pesta\u00f1a de red (network) en la consola de desarrollador del navegador podremos ver que cada 3 segundos se hace una llamada al servicio. Crear un popup para ver la informaci\u00f3n de la estaci\u00f3n al seleccionarla. Escribir justo despu\u00e9s de donde definimos el intervalo <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojson = { type : 'FeatureCollection' , features : [] }; var realtime = L . realtime ( function ( success , error ) { fetch ( 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ) . then ( function ( response ) { return response . json (); }) . then ( function ( data ) { var stations = data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , name : station . name , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } success ( geojson ); }) . catch ( error ); }, { interval : 3 * 1000 , onEachFeature ( f , l ) { l . bindPopup ( function () { return '<h3>' + f . properties . id + '</h3>' + '<p>' + f . properties . address + '</p>' + '<p>capacity: <strong>' + f . properties . capacity + '</strong></p>' + '<p>c\u00f3digo postal: ' + f . properties . post_code + '</p>' ; }); } }). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina y hacer click sobre alguna estaci\u00f3n para ver su informaci\u00f3n en tiempo real. mapa de servicio de bicing Referencias https://es.wikipedia.org/wiki/GeoJSON \u21a9 http://leafletjs.com/ \u21a9 https://github.com/perliedman/leaflet-realtime \u21a9","title":"9. Ejemplo servicio bicing Barcelona"},{"location":"9_ejemplo_servicio_bicing_bcn/#ejemplo-servicio-bicing-barcelona","text":"","title":"Ejemplo servicio bicing Barcelona"},{"location":"9_ejemplo_servicio_bicing_bcn/#acceso-al-servicio-de-datos-del-bicing-de-barcelona","text":"En el portal Open data del Ayuntamiento de Barcelona podemos encontrar un dataset (conjunto de datos) que contiene las estaciones del servicio de Bicing Anteriormente ten\u00edan un servicio donde daban toda la informaci\u00f3n de la estaci\u00f3n en tiempo real http://wservice.viabicing.cat/v2/stations . Actualmente lo han separado en dos servicios unos con la informaci\u00f3n de las estaciones (identificador, nombre, coordenadas, etc.) y otro con estado de las estaciones (n\u00famero de bicis disponibles, tipos de bicis, etc) Si bien el Ayuntamiento de Barcelona no ofrece explicitamente el acceso a los datos del Bicing como un servicio, si que tiene un servicio de datos en tiempo real. La url la podemos encontrar presionando el bot\u00f3n de Descargar del recurso json url servicio de bicing Al abrir la url https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information en nuestro navegador observaremos que la respuesta es un archivo json con un conjunto de elementos que tienen las coordenadas de la localizaci\u00f3n de la estaci\u00f3n de bicing, la direcci\u00f3n, la capacidad, etc. Mapa que utiliza este servicio, https://www.bicing.barcelona/es/mapa-de-disponibilidad-provisional El archivo json que retorna el servicio tiene coordenadas pero no es un fichero GeoJSON. 1 Para ver estos datos sobre un mapa crearemos un visor utilizando Leaflet. 2","title":"Acceso al servicio de datos del Bicing de Barcelona"},{"location":"9_ejemplo_servicio_bicing_bcn/#creacion-de-un-visor","text":"Crear una carpeta con el nombre de visor-bicing . Crear un archivo con el nombre de index.html dentro de la carpeta Abrir el archivo index.html con un editor de texto y copiar el siguiente c\u00f3digo. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Abrir el archivo index.html en el navegador para ver que carga un mapa centrado en Barcelona. Agregar el plugin para cargar datos en tiempo real. Para ellos utilizaremos el plugin Leaflet Realtime 3 . Copiar lo siguiente justo despu\u00e9s de cuando carguemos la libreria de Leaflet. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); </ script > </ body > </ html > Agregar la capa de realtime del bicing a nuestro mapa. Siguiendo el ejemplo b\u00e1sico del plugin para cagar una capa, copiar lo siguiente al final de nuestro c\u00f3digo de javascript. <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var realtime = L . realtime ({ url : 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' , crossOrigin : true , type : 'json' }, { interval : 3 * 1000 }). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina para visualizar nuestra capa de bicing. Observaremos que no aparece ning\u00fan dato. Abrir la consola de desarrollador del navegador presionando F12 y veremos que cada 3 segundos aparecer\u00e1 un error. El error es Error: Invalid GeoJSON object. . Este error es debido a lo que ya comentamos; la respuesta del servicio de Bicing no es un GeoJSON. Crear una variable llamada geojson que ser\u00e1 la que contendr\u00e1 el GeoJSON resultante de la transformaci\u00f3n, antes de la declaraci\u00f3n de nuestra capa de realtime <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojson = { type : 'FeatureCollection' , features : [] }; var realtime = L . realtime ({ url : 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' , crossOrigin : true , type : 'json' }, { interval : 3 * 1000 }). addTo ( map ); </ script > </ body > </ html > Modificar la aplicaci\u00f3n para transformar la respuesta del bicing en un GeoJSON. Modificar nuestra capa realtime con el siguiente c\u00f3digo <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojson = { type : 'FeatureCollection' , features : [] }; var realtime = L . realtime ( function ( success , error ) { fetch ( 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ) . then ( function ( response ) { return response . json (); }) . then ( function ( data ) { var stations = data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , name : station . name , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } success ( geojson ); }) . catch ( error ); }, { interval : 3 * 1000 }). addTo ( map ); </ script > </ body > </ html > Recargar la aplicaci\u00f3n y veremos los puntos de las estaciones de bicing. Si vamos a la pesta\u00f1a de red (network) en la consola de desarrollador del navegador podremos ver que cada 3 segundos se hace una llamada al servicio. Crear un popup para ver la informaci\u00f3n de la estaci\u00f3n al seleccionarla. Escribir justo despu\u00e9s de donde definimos el intervalo <!DOCTYPE html> < html > < head > < title > Servicio de Bicing realtime </ title > < link rel = \"stylesheet\" href = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /> < style > # map { position : absolute ; top : 0 ; left : 0 ; bottom : 0 ; right : 0 ; } </ style > </ head > < body > < div id = \"map\" ></ div > < script src = \"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/leaflet-realtime/2.2.0/leaflet-realtime.min.js\" ></ script > < script type = \"text/javascript\" > var map = L . map ( 'map' ); map . setView ([ 41.3887 , 2.1777 ], 13 ); L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' }). addTo ( map ); var geojson = { type : 'FeatureCollection' , features : [] }; var realtime = L . realtime ( function ( success , error ) { fetch ( 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' ) . then ( function ( response ) { return response . json (); }) . then ( function ( data ) { var stations = data . data . stations ; for ( var i = stations . length - 1 ; i >= 0 ; i -- ) { var station = stations [ i ]; var feature = { type : 'Feature' , properties : { altitude : station . altitude , name : station . name , id : station . station_id , address : station . address , post_code : station . post_code , capacity : station . capacity }, geometry : { type : 'Point' , coordinates : [ station . lon , station . lat ] } }; geojson . features . push ( feature ); } success ( geojson ); }) . catch ( error ); }, { interval : 3 * 1000 , onEachFeature ( f , l ) { l . bindPopup ( function () { return '<h3>' + f . properties . id + '</h3>' + '<p>' + f . properties . address + '</p>' + '<p>capacity: <strong>' + f . properties . capacity + '</strong></p>' + '<p>c\u00f3digo postal: ' + f . properties . post_code + '</p>' ; }); } }). addTo ( map ); </ script > </ body > </ html > Recargar la p\u00e1gina y hacer click sobre alguna estaci\u00f3n para ver su informaci\u00f3n en tiempo real. mapa de servicio de bicing","title":"Creaci\u00f3n de un visor"},{"location":"9_ejemplo_servicio_bicing_bcn/#referencias","text":"https://es.wikipedia.org/wiki/GeoJSON \u21a9 http://leafletjs.com/ \u21a9 https://github.com/perliedman/leaflet-realtime \u21a9","title":"Referencias"},{"location":"ejemplos/utilizacion-servicio-opendata/javascripts/vendor/slickgrid/2.2/","text":"Welcome to SlickGrid Find documentation and examples in the wiki . UPDATE: March 5th, 2014 - I have too many things going on in my life right now to really give SlickGrid support and development the time and attention it deserves. I am not stopping it, but I will most likely be unresponsive for some time. Sorry. SlickGrid is an advanced JavaScript grid/spreadsheet component Some highlights: Adaptive virtual scrolling (handle hundreds of thousands of rows with extreme responsiveness) Extremely fast rendering speed Supports jQuery UI Themes Background post-rendering for richer cells Configurable & customizable Full keyboard navigation Column resize/reorder/show/hide Column autosizing & force-fit Pluggable cell formatters & editors Support for editing and creating new rows. Grouping, filtering, custom aggregators, and more! Advanced detached & multi-field editors with undo/redo support. \u201cGlobalEditorLock\u201d to manage concurrent edits in cases where multiple Views on a page can edit the same data. Support for millions of rows","title":"Welcome to SlickGrid"},{"location":"ejemplos/utilizacion-servicio-opendata/javascripts/vendor/slickgrid/2.2/#welcome-to-slickgrid","text":"Find documentation and examples in the wiki . UPDATE: March 5th, 2014 - I have too many things going on in my life right now to really give SlickGrid support and development the time and attention it deserves. I am not stopping it, but I will most likely be unresponsive for some time. Sorry.","title":"Welcome to SlickGrid"},{"location":"ejemplos/utilizacion-servicio-opendata/javascripts/vendor/slickgrid/2.2/#slickgrid-is-an-advanced-javascript-gridspreadsheet-component","text":"Some highlights: Adaptive virtual scrolling (handle hundreds of thousands of rows with extreme responsiveness) Extremely fast rendering speed Supports jQuery UI Themes Background post-rendering for richer cells Configurable & customizable Full keyboard navigation Column resize/reorder/show/hide Column autosizing & force-fit Pluggable cell formatters & editors Support for editing and creating new rows. Grouping, filtering, custom aggregators, and more! Advanced detached & multi-field editors with undo/redo support. \u201cGlobalEditorLock\u201d to manage concurrent edits in cases where multiple Views on a page can edit the same data. Support for millions of rows","title":"SlickGrid is an advanced JavaScript grid/spreadsheet component"}]}